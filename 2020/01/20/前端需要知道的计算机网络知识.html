<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/dahuangmao-06.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon1.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon1.png?v=5.1.4">


  <link rel="mask-icon" href="/images/dahuangmao-06.png?v=5.1.4" color="#222">





  <meta name="keywords" content="计算机网络,HTTP,web安全,">










<meta name="description" content="浏览器背后 浏览器的一个请求从发起到返回经历了什么  浏览器中输入url，拆分解析出域名domain，将域名发送给DNS服务器 DNS服务器会根据域名查询出对应的IP地址，将IP地址返回给浏览器 浏览器在收到IP地址之后，就知道向哪个地址发起请求。TCP三次握手连接建立后，按照http网络协议发起http请求，这中间经过局域网、交换机、路由器、主干网络，最后到达服务端。 服务端一般是一个mvc">
<meta name="keywords" content="计算机网络,HTTP,web安全">
<meta property="og:type" content="article">
<meta property="og:title" content="前端需要知道的计算机网络知识">
<meta property="og:url" content="https://dunteng.github.io/2020/01/20/前端需要知道的计算机网络知识.html">
<meta property="og:site_name" content="Dunteng&#39;s Blog">
<meta property="og:description" content="浏览器背后 浏览器的一个请求从发起到返回经历了什么  浏览器中输入url，拆分解析出域名domain，将域名发送给DNS服务器 DNS服务器会根据域名查询出对应的IP地址，将IP地址返回给浏览器 浏览器在收到IP地址之后，就知道向哪个地址发起请求。TCP三次握手连接建立后，按照http网络协议发起http请求，这中间经过局域网、交换机、路由器、主干网络，最后到达服务端。 服务端一般是一个mvc">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic2.zhimg.com/v2-93c68a1fc30c635c9e4b97ca5e18b499_r.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-4c9ec3ec18a7b1da6b88b5c2b2c69179_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-7d9ed7e9624c7e7c90b902acbe9e9f74_hd.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-69209bed1ee0357a97f753bed6699a6f_hd.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-f597f8ef21ba2786b227137c77b083bf_hd.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-0435b49c6d1302c9dc9dc5deb7e80e6b_hd.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-4e1c011d189d5bfce6d144b17113a602_hd.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-b0007f9a7b3210ee36e0763e134d4f12_hd.png">
<meta property="og:image" content="https://pic4.zhimg.com/v2-f2574047a6fa34529b47e29c0d2930f3_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-a15aefbce7a4678a4532bc915b481e78_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-fcc64d38138c197aa0b71cc834ec31b4_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-01197f5ca4406f61486b978b3d9cbc66_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-b780796662bfe0496eb548a77fb89982_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-6ec75cd94fe041323576e90ce4599528_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-4884b016dafbd4acc5a90fe424c21cc0_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-7d69b34a7ba983f333cc68e67a100226_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-a60eea101f42897bdf6eeb0502a8736d_hd.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-e8349ab8b409d96ed7ad1675e1453734_r.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-6b6db1c200960278e4ffcd4fb4a9c505_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-ef2e130509c22c27f879d2d70b355ab3_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-82ce83612a98f400c1b3188e3be9a12a_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-0dbfe5d2315736de1b8325d4645de877_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-d3984ae80de4ac61ad8ff37a0441c310_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-3692646ea02e76164704f42993a1d5bc_r.jpg">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/591228/201601/591228-20160116223301225-1866838315.png">
<meta property="og:image" content="http://dl.iteye.com/upload/attachment/0069/3485/1a4e7e6a-6d7b-38f1-af8a-043140034c8f.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-17b1ca0ebef690c80048ed2047192bc5_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-4cb1d86b8082d06136f07d926d2215cb_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-752d2c6b47d8ef92a8eeffb3ace69b1f_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-f2fb26b34779c19804dfc7b7983d90da_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-4fc1f2861eab11d573cce50abb068cfb_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-63f69d8e86d7d3a039d17375031ca296_hd.png">
<meta property="og:image" content="https://pic4.zhimg.com/v2-d50243d48d5ddb8fa92ec05b9c20aa1f_r.jpg">
<meta property="og:image" content="http://dl.iteye.com/upload/attachment/0069/3489/0236098f-1a98-3a4f-ba6c-4a44c6ec4ed0.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-dc3015a969a414a27e97eb4f2c379117_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-b7890e03668aaadb66efe9ef19949e78_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-6c36853c43ab1ca664149029a56224ff_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-6b5e6e14753632151fae1a62af0b55fb_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-aa8f935ab1ede1af9b1fd20e36649838_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-eb8ddcadfad6aaaf652fee535d4aa15c_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-e487502215497883f21144e160dd51ad_hd.png">
<meta property="og:image" content="https://pic3.zhimg.com/v2-9e1cd55a0db3aeeafdcc874d83148f36_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-798b3db38f19de8e4fd023bde9950172_r.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-0c073a2e526b762ddfff7ec9cf8c4855_r.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-1a0ab33c48d5ef80e8031837056f5dc4_hd.png">
<meta property="og:image" content="https://pic1.zhimg.com/v2-9f78b0761755943e5757296cbe5040bc_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-505f23eabd3400f97bf5e82bafd63911_hd.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-cc7f76d3394b7a4a1379da7fed89224d_hd.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-78ff5d6d033da64ff06c3b10344d7e09_hd.png">
<meta property="og:image" content="https://pic2.zhimg.com/v2-8c7bac3dcc754caa225e826a2f74da8d_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-4b2d93c38a1924ac8746c884b14ef6af_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-983ed96f06690c848061c1abdc8f41c7_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-16fd13ed150171630d7ada72bf1860c4_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-af381740b7676fbd8f89681cbb99c6ee_r.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-fff9f2850d504f3d129f3bec11d54fa1_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-7f176794f2dc6ce1f6cfe490853c9073_r.jpg">
<meta property="og:image" content="https://pic.xiaohuochai.site/blog/HTTP_gateway4.jpg">
<meta property="og:image" content="https://pic.xiaohuochai.site/blog/HTTP_gateway5.jpg">
<meta property="og:image" content="https://pic.xiaohuochai.site/blog/HTTP_gateway6.jpg">
<meta property="og:image" content="https://pic.xiaohuochai.site/blog/HTTP_gateway7.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-e04ce39e4cb49751f44e4644451fde77_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-650886977ac33ef888180368249106ae_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-c3186628332d228b6676bc6ad9482cea_r.jpg">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1213309/201808/1213309-20180812210442732-1599210158.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1213309/201808/1213309-20180812215938593-1709664851.png">
<meta property="og:image" content="https://pic4.zhimg.com/v2-283bc5b378a63a0bc07099c824680c6b_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-274d4f6d5a04c2dcde944d6f4cfdc73c_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-f44db3085c661cd5ed65ec091333e45e_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-f3ab1daafe9daa179a15d447467c7aed_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-d2daf8ba5615dc9d427a6fe3d20d1031_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-d3ecc2fa78ccaed37c478b4055198ceb_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-9a458296959c052b026560a5892368f2_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-5123c1a68be44a178c6f6c1543dfc3f1_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-d67c298621ff7b0993bf40fada27f573_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-e94e6b7dc1376c799ae3e1aadc469ea2_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-4a394ede38b526839ce8ada8643934c6_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-35e555a8c74fbddc32ff610819480936_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-123b8861cdefd9a322760ec7591f1cde_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-e8288a959d6fbd5019fa91c0e0b370f2_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-4e1c4a6836c8a4b0c7511a0d21710664_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-98502876ee22cbe643e3cd2a6ad74c2e_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-761d4917160cc15f06056f7043a84307_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-abd130a15c5ba261a42f93add277948f_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-0473074a3253131c0ad3ef4902cb2fb8_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-3db9b326b9d31745229a26a877a1308c_hd.jpg">
<meta property="og:image" content="data:image/png;base64,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">
<meta property="og:image" content="https://pic1.zhimg.com/v2-c91c2ee4afd3dbf92199aba00e84eae0_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/7c0cf075c7ee4cc6cf52f4572a4c1c10_b.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20180912153834839?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAyMzA3OTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://pic3.zhimg.com/faedeb3dae59455f6520d6a5dbf436e5_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/b1e608ddb7493608efea3e76912aabe1_hd.jpg">
<meta property="og:image" content="https://segmentfault.com/img/bVbgpF3?w=494&h=138">
<meta property="og:image" content="http://www.alloyteam.com/wp-content/uploads/2015/03/stream.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-85da1ac1cd92134019fbcfbe7161257e_r.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-0a847430b0a7696a1c2d59ecb7e715bd_r.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-b4b3eb89464b192eed0304e5647a2d26_hd.jpg">
<meta property="og:image" content="https://image.fundebug.com/2019-03-06-8.png">
<meta property="og:image" content="https://image.fundebug.com/2019-03-06-9.png">
<meta property="og:image" content="https://pic2.zhimg.com/v2-9d75b28cfede20e3caf3d1f8df491e05_r.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-3ed5a7f3bb2743324320fa446d4b167c_r.jpg">
<meta property="og:updated_time" content="2020-03-02T12:16:28.897Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端需要知道的计算机网络知识">
<meta name="twitter:description" content="浏览器背后 浏览器的一个请求从发起到返回经历了什么  浏览器中输入url，拆分解析出域名domain，将域名发送给DNS服务器 DNS服务器会根据域名查询出对应的IP地址，将IP地址返回给浏览器 浏览器在收到IP地址之后，就知道向哪个地址发起请求。TCP三次握手连接建立后，按照http网络协议发起http请求，这中间经过局域网、交换机、路由器、主干网络，最后到达服务端。 服务端一般是一个mvc">
<meta name="twitter:image" content="https://pic2.zhimg.com/v2-93c68a1fc30c635c9e4b97ca5e18b499_r.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'GX48388M0Z',
      apiKey: '24910416df90ea04217402b818109cef',
      indexName: 'index',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dunteng.github.io/2020/01/20/前端需要知道的计算机网络知识.html">





  <title>前端需要知道的计算机网络知识 | Dunteng's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6ffc4435fb9941ca00fb4c7e08d8fca2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunteng's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunteng.github.io/2020/01/20/前端需要知道的计算机网络知识.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dunteng Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunteng's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端需要知道的计算机网络知识</h1>
        

        <div class="post-meta">
		
    <i class="fa fa-thumb-tack"></i>
    <font color="orange">置顶</font>
    <span class="post-meta-divider">|</span>

          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-20T00:00:00+08:00">
                2020-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/20/前端需要知道的计算机网络知识.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/20/前端需要知道的计算机网络知识.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <meta name="referrer" content="no-referrer">

<h2 id="浏览器背后"><a href="#浏览器背后" class="headerlink" title="浏览器背后"></a>浏览器背后</h2><p><img src="https://pic2.zhimg.com/v2-93c68a1fc30c635c9e4b97ca5e18b499_r.jpg" alt=""></p>
<h3 id="浏览器的一个请求从发起到返回经历了什么"><a href="#浏览器的一个请求从发起到返回经历了什么" class="headerlink" title="浏览器的一个请求从发起到返回经历了什么"></a>浏览器的一个请求从发起到返回经历了什么</h3><p><img src="https://pic2.zhimg.com/v2-4c9ec3ec18a7b1da6b88b5c2b2c69179_r.jpg" alt=""></p>
<ol>
<li>浏览器中输入url，拆分解析出域名domain，将域名发送给DNS服务器</li>
<li>DNS服务器会根据域名查询出对应的IP地址，将IP地址返回给浏览器</li>
<li>浏览器在收到IP地址之后，就知道向哪个地址发起请求。TCP三次握手连接建立后，按照http网络协议发起http请求，这中间经过局域网、交换机、路由器、主干网络，最后到达服务端。</li>
<li>服务端一般是一个mvc架构，请求首先会进入Controller层，在controller中进行相关的逻辑处理和请求的分发，之后去调用model层，model层负责与数据交互，在与数据交互的过程中，model层会操作数据库（redis、mysql等）增删改查等，最终将页面数据通过view层返回给网络。这样，一个http response就从服务端返回给了浏览器。</li>
<li>接下来浏览器主要是做一个render渲染的过程，浏览器根据请求回来的html以及这个html关联的css、js去进行渲染。在渲染的过程中，会根据html形成对应的DOM树和CSS树，从而进行页面内容的渲染。</li>
</ol>
<h2 id="初识HTTP协议"><a href="#初识HTTP协议" class="headerlink" title="初识HTTP协议"></a>初识HTTP协议</h2><p><img src="https://pic3.zhimg.com/80/v2-7d9ed7e9624c7e7c90b902acbe9e9f74_hd.png" alt=""></p>
<ul>
<li>1990年10月HTTP协议被提出</li>
<li>1991年HTTP0.9诞生</li>
<li>1996年HTTP1.0发布</li>
<li>1997年HTTP1.1发布（目前最常用的版本）</li>
<li>2015年HTTP2.0发布（主要是HTTP1.x 的扩展，提高了传输性能，实现低延迟，高吞吐量；但是目前普及率不高，2019年底只有30%的网站在使用）</li>
<li>HTTP3.0 现在已经发布了，但尚未普及。了解一下<a href="https://www.jianshu.com/p/bb3eeb36b479" target="_blank" rel="noopener">QUIC协议</a></li>
</ul>
<h2 id="TCP-IP协议族与HTTP协议"><a href="#TCP-IP协议族与HTTP协议" class="headerlink" title="TCP/IP协议族与HTTP协议"></a>TCP/IP协议族与HTTP协议</h2><p>HTTP协议是构建在TCP/IP协议之上的，是TCP/IP协议的一个子集。为了更好的了解HTTP协议，我先来介绍一下TCP/IP 的相关知识。</p>
<p><strong>TCP/IP协议族</strong></p>
<ul>
<li>TCP/IP协议是一系列与互联网相关联的协议集合起来的总称</li>
<li>分层管理是TCP/IP协议的重要特征</li>
</ul>
<h3 id="TCP-IP分层"><a href="#TCP-IP分层" class="headerlink" title="TCP/IP分层"></a>TCP/IP分层</h3><p><img src="https://pic3.zhimg.com/80/v2-69209bed1ee0357a97f753bed6699a6f_hd.png" alt=""></p>
<p><img src="https://pic3.zhimg.com/80/v2-f597f8ef21ba2786b227137c77b083bf_hd.png" alt=""></p>
<p><img src="https://pic2.zhimg.com/80/v2-0435b49c6d1302c9dc9dc5deb7e80e6b_hd.png" alt=""></p>
<p>TCP协议是面向连接的，UDP协议是无连接的。TCP虽然可靠，但是因为需要建立连接，效率较低，而UDP则效率高，但可靠性低。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4e1c011d189d5bfce6d144b17113a602_hd.png" alt=""></p>
<p><strong>网络层负责在众多的串数路线中选择一条供两台计算机直接通信。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-b0007f9a7b3210ee36e0763e134d4f12_hd.png" alt=""></p>
<p>相关知识：<a href="https://blog.csdn.net/huangjin0507/article/details/51613561" target="_blank" rel="noopener">OSI七层与TCP/IP五层网络架构</a></p>
<h3 id="数据封装与数据传输"><a href="#数据封装与数据传输" class="headerlink" title="数据封装与数据传输"></a>数据封装与数据传输</h3><p><img src="https://pic4.zhimg.com/v2-f2574047a6fa34529b47e29c0d2930f3_r.jpg" alt=""></p>
<p><img src="https://pic1.zhimg.com/v2-a15aefbce7a4678a4532bc915b481e78_r.jpg" alt=""></p>
<p>基本可以理解为封装快递=》寄送快递=》拆快递的过程。</p>
<h3 id="TCP连接的建立和释放"><a href="#TCP连接的建立和释放" class="headerlink" title="TCP连接的建立和释放"></a>TCP连接的建立和释放</h3><p><img src="https://pic1.zhimg.com/v2-fcc64d38138c197aa0b71cc834ec31b4_r.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-01197f5ca4406f61486b978b3d9cbc66_r.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-b780796662bfe0496eb548a77fb89982_r.jpg" alt=""></p>
<p><img src="https://pic1.zhimg.com/v2-6ec75cd94fe041323576e90ce4599528_r.jpg" alt=""></p>
<ul>
<li><p><a href="https://www.bilibili.com/video/av69145968?from=search&amp;seid=9065169420287984816" target="_blank" rel="noopener">视频</a></p>
</li>
<li><p><img src="https://pic1.zhimg.com/v2-4884b016dafbd4acc5a90fe424c21cc0_r.jpg" alt="1571061079139"></p>
</li>
<li><p>客户端和服务器端的前两次握手其实就可以建立链接了，为什么还要进行第三次握手才能建立链接。因为有这种情况：第一次握手客户端传过去的数据因为网络阻塞等原因没能顺利传到服务器，那么服务器端就不会发送确认报文给客户端，由于存在一个<strong>超时重传</strong>的机制，客户端久久未收到服务器端的报文就会重新再发一次请求，好了，这次服务器端手里接收到了，也发回了确认报文给客户端，然后客户端发送一个确认报文给服务器端告诉服务器端”我收到你接受成功的消息了“，服务器就知道ok消息都传到了可以建立链接了。恰巧这时第一次未发送成功的请求终于不阻塞了传到了服务器端，但是这时已经不需要这条迟来的请求了，服务器通过第三次握手就知道了一切就绪就不会再接受重复的请求了。</p>
<p>还有一种说法：第一次握手，服务端知道了客户端的发送功能正常、自己服务端的接收功能正常，但不知道客户端的接收能力正常否，也不知道自己服务端的发送功能正常否，所以服务端向客户端发送请求，于是有了第二次握手；第二次握手时，客户端接收到了来自服务端的消息，知道了自己客户端的发送功能和接收功能都是正常的、服务端的接收功能和发送功能也是正常的，但是服务端这时候还没有全知道，所以要通知一下服务端，于是有了第三次握手；第三次握手时，服务端就知道了自己的发送功能和接收功能都是正常的，客户端的发送和接收功能也是正常的，可以开始数据传送了。</p>
</li>
<li><p><img src="https://pic3.zhimg.com/v2-7d69b34a7ba983f333cc68e67a100226_r.jpg" alt="1571061644203"></p>
</li>
<li><p>一开始客户端向服务端发送报文说我要关闭了，服务器端接收到报文知道客户端要关闭，于是就向客户端发送报文说收到你可以关闭，这时第一第二次挥手；服务器端发送完二次挥手的报文后，会等待一段时间(CLOSE-WAIT)，在这期间服务器端可能会有其他的发往客户端的报文，所以要等这些报文发完之后才进行第三次挥手；第三次挥手时服务器端向客户端发送报文告知客户端自己也要关闭了，客户端接收到了然后向服务器端发送一条报文告知我知道你要关闭了，这是第四次挥手。第四次挥手后客户端会等到一段时间(TIME-WAIT)再关闭，因为有这么一种情况：</p>
<ul>
<li>服务端在第三次挥手发送报文后，会等到接收到来自客户端的第四次挥手的报文之后才安心地关闭。但由于网路阻塞等不可控因素，客户端发送的第四次挥手的报文可能没有顺利传送到服务器端，服务器端会有一个超时重传的机制，它迟迟没有收到客户端的回应就会重新发送第三次挥手的报文，如果没有TIME-WAIT，客户端在收到三次挥手报文并发送第四次挥手报文后就直接关闭了，那么可能因为第四次挥手没有顺利传送到服务器端，而导致服务器端一直无法关闭。所以设置一个TIME-WAIT是很有必要的。</li>
</ul>
</li>
</ul>
<h2 id="DNS域名解析和CDN"><a href="#DNS域名解析和CDN" class="headerlink" title="DNS域名解析和CDN"></a>DNS域名解析和CDN</h2><p><img src="https://pic3.zhimg.com/80/v2-a60eea101f42897bdf6eeb0502a8736d_hd.png" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg" alt=""></p>
<p>[参考文章]</p>
<p><a href="https://www.cnblogs.com/crazylqy/p/7110357.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7110357.html</a></p>
<p><a href="https://juejin.im/entry/5ad011216fb9a028cd457f60" target="_blank" rel="noopener">https://juejin.im/entry/5ad011216fb9a028cd457f60</a></p>
<p>CDN(内容分发网络)作用于DNS域名解析之前，CDN决定分发了一个较近的站点给用户，接着再进行DNS域名解析。</p>
<h2 id="开发者工具查看http请求头响应头响应体"><a href="#开发者工具查看http请求头响应头响应体" class="headerlink" title="开发者工具查看http请求头响应头响应体"></a>开发者工具查看http请求头响应头响应体</h2><p><img src="https://pic1.zhimg.com/v2-e8349ab8b409d96ed7ad1675e1453734_r.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-6b6db1c200960278e4ffcd4fb4a9c505_r.jpg" alt=""></p>
<h2 id="HTTP协议五大特点"><a href="#HTTP协议五大特点" class="headerlink" title="HTTP协议五大特点"></a>HTTP协议五大特点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 支持客户端/服务器端模式（CS模式）</span><br><span class="line">- 简单快速</span><br><span class="line">- 灵活</span><br><span class="line">- 无连接</span><br><span class="line">- 无状态</span><br></pre></td></tr></table></figure>
<p>参考文章：<a href="https://blog.csdn.net/tennysonsky/article/details/44562435" target="_blank" rel="noopener">https://blog.csdn.net/tennysonsky/article/details/44562435</a></p>
<p><img src="https://pic4.zhimg.com/v2-ef2e130509c22c27f879d2d70b355ab3_r.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-82ce83612a98f400c1b3188e3be9a12a_r.jpg" alt=""></p>
<p><img src="https://pic4.zhimg.com/v2-0dbfe5d2315736de1b8325d4645de877_r.jpg" alt=""></p>
<p><img src="https://pic1.zhimg.com/v2-d3984ae80de4ac61ad8ff37a0441c310_r.jpg" alt=""></p>
<p><img src="https://pic1.zhimg.com/v2-3692646ea02e76164704f42993a1d5bc_r.jpg" alt=""></p>
<h2 id="URI和URL的区别与联系"><a href="#URI和URL的区别与联系" class="headerlink" title="URI和URL的区别与联系"></a>URI和URL的区别与联系</h2><p>参考文章：<a href="https://blog.csdn.net/u011240877/article/details/52052378" target="_blank" rel="noopener">https://blog.csdn.net/u011240877/article/details/52052378</a></p>
<p><img src="http://images2015.cnblogs.com/blog/591228/201601/591228-20160116223301225-1866838315.png" alt=""></p>
<p>URI： 一个紧凑的字符串用来标示抽象或物理资源</p>
<p>一个URI可以进一步被分为定位符、名字或者两者都是.。或者说URI可以分为URL和URN或者同时具备locators和names特性。</p>
<p>URL（统一资源定位器）是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制。</p>
<p>URN作用就好像一个人的名字，URL就像一个人的地址。</p>
<p>URN确定了东西的身份，URL提供了找到它的方式。</p>
<p>URL是URI的一种，但不是所有的URI都是URL。</p>
<p>URI和URL的最大差别是“访问机制”。</p>
<p>来看几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ftp://ftp.is.co.za/rfc/rfc1808.txt (*)</span><br><span class="line"></span><br><span class="line">http://www.ietf.org/rfc/rfc2396.txt (*)</span><br><span class="line"></span><br><span class="line">ldap://[2001:db8::7]/c=GB?objectClass?one (*)</span><br><span class="line"></span><br><span class="line">mailto:John.Doe@example.com (*)</span><br><span class="line"></span><br><span class="line">news:comp.infosystems.www.servers.unix (*)</span><br><span class="line"></span><br><span class="line">tel:+1-816-555-1212</span><br><span class="line"></span><br><span class="line">telnet://192.0.2.16:80/ (*)</span><br><span class="line"></span><br><span class="line">urn:oasis:names:specification:docbook:dtd:xml:4.1.2</span><br></pre></td></tr></table></figure>
<p>上述例子均为URI，其中<strong>带有*结尾的例子为URL</strong>，他们之间存在的共性是什么？不难发现，URL的例子复制粘贴到浏览器地址栏可以直接访问到资源，也就是说URL提供了访问机制，这是判断是否为URL的决定性因素。</p>
<p>总结：</p>
<p>关于URL和URI区别之争，其实并没有多大意义，因为URL就是URI。但对于一个标识符一个准确说法却是有考究上的帮助，当我们替代WEB地址时，哪个说法更为准确，通过了解到两者的包含的关系，URI毫无疑问是最保险的说法。要严谨请使用URI吧。而且，”URL”也正在被“弃用”。</p>
<h2 id="HTTP报文结构分析"><a href="#HTTP报文结构分析" class="headerlink" title="HTTP报文结构分析"></a>HTTP报文结构分析</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src="http://dl.iteye.com/upload/attachment/0069/3485/1a4e7e6a-6d7b-38f1-af8a-043140034c8f.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-17b1ca0ebef690c80048ed2047192bc5_r.jpg" alt=""></p>
<h3 id="HTTP报文头"><a href="#HTTP报文头" class="headerlink" title="HTTP报文头"></a>HTTP报文头</h3><p>HTTP报文头分为四类，分别是：</p>
<ul>
<li>通用报文头</li>
<li>请求报文头</li>
<li>响应报文头</li>
<li>实体报文头</li>
</ul>
<p>在HTTP/1.1里一共规范了47种<strong>报文头字段</strong></p>
<p><img src="https://pic4.zhimg.com/v2-4cb1d86b8082d06136f07d926d2215cb_r.jpg" alt=""></p>
<p><img src="https://pic4.zhimg.com/v2-752d2c6b47d8ef92a8eeffb3ace69b1f_r.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-f2fb26b34779c19804dfc7b7983d90da_r.jpg" alt=""></p>
<p><img src="https://pic4.zhimg.com/v2-4fc1f2861eab11d573cce50abb068cfb_r.jpg" alt=""></p>
<h3 id="常见的报文头字段"><a href="#常见的报文头字段" class="headerlink" title="常见的报文头字段"></a>常见的报文头字段</h3><p><strong>ACCEPT</strong>：</p>
<p>作用： 浏览器端可以接收的媒体类型</p>
<p>Accept: text/html 代表浏览器可以接收服务器发回的类型是text/html，也就是我们常说的html文档，如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(Non Acceptable)。</p>
<p>Accept: */* 代表浏览器可以处理所有类型。</p>
<p>如果想要给显示的媒体类型增加优先级，则使用 q= 来额外标识权重值；权重值 q 的范围是 0~1 （可精确到小数点后3位），且1为最大值。不指定权重 q 值时，默认权重为 q=1.0。 当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<hr>

<p><strong>Accept-Encoding</strong>：</p>
<p>作用：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩（gzip  deflate）</p>
<p>accept-encoding: gzip, deflate</p>
<hr>

<p><strong>Accept-Language</strong>：</p>
<p>作用： 浏览器申明自己接收的语言</p>
<p>Accpet-language: zh-cn,zh;q=0.7,en-us,en;q=0.3</p>
<p>这个字段也是有权重值的。客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，若无，则返回英文版的响应，若再无，返回406错误。</p>
<hr>

<p><strong>Connection</strong>：</p>
<p>Connection: keep-alive   当一个网页打开完成后，客户端和服务器端之间用于串数HTTP数据的TCP连接不会断开，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p>
<p>Connection: close  代表一个request完成后，客户端与服务器端之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送request，需要重新通过三次握手建立TCP连接。</p>
<hr>

<p><strong>Host</strong>：</p>
<p>host请求报文域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL种提取出来</p>
<p>我们在浏览器种输入： <a href="http://www.dunteng.com:8080" target="_blank" rel="noopener">http://www.dunteng.com:8080</a></p>
<p>浏览器发送的请求消息中，就会包含host请求报头域，如下：</p>
<p>Host: <a href="http://www.dunteng.com:8080" target="_blank" rel="noopener">www.dunteng.com:8080</a></p>
<hr>

<p><strong>Referer</strong>：</p>
<p>当浏览器向web服务器发送请求时，一般会带上Referer，告知服务器我是从哪个页面链接过来的，服务器藉此可以获得一些信息用于处理。</p>
<hr>

<p><strong>User-Agent</strong>：</p>
<p>作用： 告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本。</p>
<p>很多情况下我们会通过User-Agent来判断浏览器类型，从而进行不同的兼容设计。</p>
<hr>

<p><strong>Content-Type：</strong></p>
<p>作用： 说明了报文体内对象的媒体类型</p>
<p><img src="https://pic4.zhimg.com/80/v2-63f69d8e86d7d3a039d17375031ca296_hd.png" alt=""></p>
<p><img src="https://pic4.zhimg.com/v2-d50243d48d5ddb8fa92ec05b9c20aa1f_r.jpg" alt=""></p>
<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src="http://dl.iteye.com/upload/attachment/0069/3489/0236098f-1a98-3a4f-ba6c-4a44c6ec4ed0.jpg" alt=""></p>
<p><img src="https://pic4.zhimg.com/v2-dc3015a969a414a27e97eb4f2c379117_r.jpg" alt=""></p>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>HTTP/1.1 常用方法：</p>
<ol>
<li>GET</li>
<li>POST</li>
<li>PUT</li>
<li>HEAD</li>
<li>DELETE</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>CONNECT</li>
</ol>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET方法用来请求访问被URI识别的资源，指定的资源经服务器解析后返回相应内容。</p>
<p><img src="https://pic1.zhimg.com/v2-b7890e03668aaadb66efe9ef19949e78_r.jpg" alt=""></p>
<p>GET方法也可以用来提交表单和其他数据，以下例的格式👇</p>
<p><a href="http://localhost/login.php?username=44&amp;password=1234" target="_blank" rel="noopener">http://localhost/login.php?username=44&amp;password=1234</a></p>
<p>从上面的URL请求中，很容易辨认出表单提交的内容，这样很不安全。同时，浏览器对于提交URL的长度也有所限制。</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST方法与GET功能类似，一般用来传输实体的主体，常用来提交表单数据，尤其是大批量的数据</p>
<p><img src="https://pic4.zhimg.com/v2-6c36853c43ab1ca664149029a56224ff_r.jpg" alt=""></p>
<ul>
<li>POST方法将要提交的数据存放在请求体中，而非GET那种将数据以参数形式放在URL中，相比较而言隐私安全较好。所以，处于安全和用户隐私的考量，提交表单数据一般采用POST为宜。</li>
<li>GET方法对于提交的数据（URL长度）有大小限制，POST无大小限制</li>
</ul>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>从客户端向服务器传送的数据取代指定的文档的内容</p>
<p>PUT方法与POST方法最大的不同是PUT是<strong>幂等</strong>的，而POST不是幂等的</p>
<p><a href="https://q.cnblogs.com/q/98586/" target="_blank" rel="noopener">PUT没有验证机制，任何人都可以上传，有安全问题，一般网站都不使用该方法。（出自《图解HTTP》，不是很明白）</a></p>
<p>更多时候将PUT方法用作传输资源</p>
<p>在 HTTP 协议支持的方法中，PUT 和 POST 是比较容易混淆的一对。我们来看看在 RESTful API 中应该如何正确使用这两种方法。</p>
<p>从语义的角度来说，HTTP PUT 方法的含义和 Java Map 中的 <code>put</code> 方法是一致的。下面是 Java Doc 的摘录。</p>
<blockquote>
<p>V put(K key, V value)</p>
<p>Associates the specified value with the specified key in this map (optional operation).<br>If the map previously contained a mapping for the key, the old value is replaced by the specified value.</p>
</blockquote>
<p>如果从 RESTful API 的角度来理解，PUT 方法是这么工作的：</p>
<ol>
<li>把一个对象 <code>V</code> 绑定到地址 <code>K</code> 上；今后请求地址 <code>K</code> 时，就会返回对象 <code>V</code>。</li>
<li>如果地址 <code>K</code> 之前曾绑定过另一个对象，比如 <code>V0</code>，那么 <code>V0</code> 会被 <code>V</code> 替换。</li>
</ol>
<p>举一个简单的例子，假设我的博客后台支持 RESTful API，我可以通过下面的请求发布这篇文章：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT https://bitmingw.com/2018/04/16/http-put-vs-post HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    /* 文章内容正文 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，使用 PUT 方法时，客户端需要在 HTTP 请求中明确指定地址 <code>K</code>。</p>
<p>正如 Java 的例子一样，PUT 方法应当支持幂等性。如果是同一个对象 <code>V</code>，<strong>PUT 多次与 PUT 一次返回的结果应该是相同的</strong>。客户端可以利用 PUT 的幂等性安全地重试请求，保证客户端的请求至少被服务端处理一次。</p>
<p>如果把上面发布文章的例子用 HTTP POST 方法重写，它可能会是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST https://bitmingw.com/post-article HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    /* 文章内容正文 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，地址 <code>K</code> 不是由客户端指定的，而是由服务端生成的。比如，服务端可能会根据日期和文章标题，为本文分配一个地址。</p>
<p>另外，与 PUT 方法不同<strong>，POST 方法是不支持幂等性的。同一个请求被处理两次，应当生成两份对象</strong>。</p>
<p>现在问题来了，如果真的遇到了网络故障，客户端应该如何重试 POST 请求呢？解决方法其实很简单，我们可以在 POST 请求中隐藏一个唯一的 token，服务端在处理请求后把 token 存入数据库，如果这个 token 之前遇到过，服务端就知道这是重复的 POST 请求，可以不再处理了。</p>
<p>另外实际开发中，更新操作一般不使用PUT，因为不是很安全，而是采用POST，但是在代码逻辑层面进行数据标识的判断，避免了POST的非幂等性的问题，同时POST还比PUT安全。</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>类似于GET方法，只不过返回的响应中没有具体的内容，用于获取响应报文头。</p>
<p>常用于测试超链接的有效性。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>请求服务器删除指定资源。和PUT一样，DELETE也缺乏验证机制。</p>
<p>项目中一般不使用DELETE，使用DELETE很可能是个安全漏洞。</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>用来查询服务器支持哪些HTTP方法</p>
<p>OPTIONS它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”</p>
<p><img src="https://pic4.zhimg.com/v2-6b5e6e14753632151fae1a62af0b55fb_r.jpg" alt=""></p>
<p>在上图中，我向服务器端发起了一个OPTIONS方法的请求，返回的数据中allow中显示了该URI所支持的HTTP方法。</p>
<h3 id="TARCE"><a href="#TARCE" class="headerlink" title="TARCE"></a>TARCE</h3><p>回显服务器端收到的请求，主要用于测试和诊断。（很少用，容易引发安全漏洞）</p>
<p>客户端发起一个TRACE方法的HTTP请求，看一下服务端回显的客户端请求，监测其是否被修改或篡改过。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>开启一个客户端与所请求资源之间的双向沟通的渠道，它可以用来创建隧道。</p>
<p>一般用于HTTP代理。当用户使用HTTP代理服务器来访问网站的时候，就会用到CONNECT方法。比如通过HTTP代理来访问Facebook，首先浏览器向代理服务器发送一个CONNECT方法的请求，代理服务器返回200的状态码，告知链接成功建立，之后浏览器就和服务器握手并交换数据，代理服务器只负责传输彼此的数据包，并不能读取具体的数据内容，不管是HTTPs还是HTTP，都是如此。</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码是用以标识网页服务器超文本传输协议响应状态的3位数字代码。</p>
<p><img src="https://pic1.zhimg.com/v2-aa8f935ab1ede1af9b1fd20e36649838_r.jpg" alt=""></p>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p><img src="https://pic1.zhimg.com/v2-eb8ddcadfad6aaaf652fee535d4aa15c_r.jpg" alt=""></p>
<p>举个生活中的例子：</p>
<p>202：你要请我吃饭，我说好，然后我俩就去吃饭了。</p>
<p>202：你要请我吃饭，但是要请我吃饭的人太多了，还轮不到你，你先排着队，排到你了咋就去吃。</p>
<p>206：你要请我吃饭，咱吃上了。吃到一半，我去接个电话，打完电话，回来接着吃。</p>
<p>206常见于HTTP断点续传，举个例子：我在下载电影，下到一半网线被拔了，之后我又重新接上网线，这时如果有断点续传，就可以不用重头下载，而是在中断的地方接着下载。</p>
<p>再补充几个2xx的状态码：</p>
<p><strong>204：</strong>请求执行成功，但是没有数据，<strong>浏览器不用刷新页面.也不用导向新的页面</strong>。如何理解这段话呢。还是通过例子来说明吧，假设页面上有个form，提交的url为http-204.htm，提交form，正常情况下，页面会跳转到http-204.htm，但是如果http-204.htm的相应的状态码是204，此时页面就不会发生转跳，还是停留在当前页面。另外对于a标签，如果链接的页面响应码为204，页面也不会发生跳转。</p>
<hr>

<p><img src="https://pic4.zhimg.com/80/v2-e487502215497883f21144e160dd51ad_hd.png" alt=""></p>
<p><strong>301适合永久重定向</strong></p>
<p>　　301比较常用的场景是使用域名跳转。</p>
<p>　　比如，我们访问 <strong>http</strong>://zhihu.com 会跳转到 <strong>https</strong>://<a href="http://www.zhihu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。" target="_blank" rel="noopener">www.zhihu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。</a> </p>
<p><img src="https://pic3.zhimg.com/v2-9e1cd55a0db3aeeafdcc874d83148f36_r.jpg" alt=""></p>
<p>　　<strong>注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。</strong></p>
<p>　    <strong>或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。</strong></p>
<p><strong>302用来做临时跳转</strong></p>
<p>　　比如未登陆的用户访问知乎首页临时重定向到登录页面。</p>
<p><img src="https://pic3.zhimg.com/v2-798b3db38f19de8e4fd023bde9950172_r.jpg" alt=""></p>
<p><strong>304：</strong> 如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。 简单的表达就是：服务端已经执行了GET，但文件未变化。</p>
<p>我访问<a href="https://pic4.zhimg.com/v2-983ed96f06690c848061c1abdc8f41c7_r.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/v2-983ed96f06690c848061c1abdc8f41c7_r.jpg</a>的时候就是304</p>
<hr>

<p><img src="https://pic2.zhimg.com/v2-0c073a2e526b762ddfff7ec9cf8c4855_r.jpg" alt=""></p>
<hr>

<p><img src="https://pic2.zhimg.com/80/v2-1a0ab33c48d5ef80e8031837056f5dc4_hd.png" alt=""></p>
<p>补充一下其他的常见5xx状态码：</p>
<p><strong>501：</strong>　服务器不具备完成请求的功能。例如，我尝试用options方法请求baidu.com，而badu.com服务端不具备options的请求。</p>
<p><strong>503：</strong>　服务器目前无法使用（由于超载或停机维护）</p>
<p><strong>504：</strong>    Bad Gateway timeout 网关超时</p>
<p><strong>505：</strong>　服务器不支持请求中所用的 HTTP 协议版本。</p>
<p>状态码参考文章和链接：</p>
<p><a href="https://www.jianshu.com/p/93555718732a" target="_blank" rel="noopener">https://www.jianshu.com/p/93555718732a</a></p>
<p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">https://www.runoob.com/http/http-status-codes.html</a></p>
<h2 id="HTTP状态管理（会话机制）：Cookie和Session"><a href="#HTTP状态管理（会话机制）：Cookie和Session" class="headerlink" title="HTTP状态管理（会话机制）：Cookie和Session"></a>HTTP状态管理（会话机制）：Cookie和Session</h2><p>前面说过，HTTP是无状态的，即对于每一次请求都是一个全新的请求，服务器不保存上一次请求的信息，就是它记不住东西，这种特性优点是解放了服务器，缺点就是每次要重复传输大量的信息。所以需要cookie和session来帮它做状态管理，cookie和session都是会话跟踪技术。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>cookie实际上是一小段的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，同时这个浏览器是第一次访问本服务器，那么服务器就生成session和对应的session id，并通过response向客户端浏览器颁发这个session id，同时记录起来这个session（如存入数据库中）</p>
<p>客户端浏览器会把服务端传来的session id用cookie保存起来。当浏览器再请求该网站的时候，浏览器就把请求的网址连同该cookie以通提交给服务器，服务器检查该cookie中的session id，以此来辨认用户状态。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>session是<strong>服务器端使用的</strong>一种记录客户端状态的机制。session是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。</p>
<p>客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>cookie可以长期有效，但session存在有效期，有以下几种情况session会失效：</p>
<ul>
<li>session超时失效</li>
<li>程序调用HttpSession.invalidate()主动注销session，一般在用户退出登录或注销的时候发生</li>
<li>session一般存在于服务器的内存中，当内存溢出时或者服务器进程中止时，session也就失效了。</li>
</ul>
<p>”关闭浏览器后session就失效了“这种说法不准确，原因详见<a href="https://blog.csdn.net/zgrjkflmkyc/article/details/53706195" target="_blank" rel="noopener">此文章</a>。</p>
<h3 id="cookie与session配合使用"><a href="#cookie与session配合使用" class="headerlink" title="cookie与session配合使用"></a>cookie与session配合使用</h3><p><img src="https://pic1.zhimg.com/v2-9f78b0761755943e5757296cbe5040bc_r.jpg" alt=""></p>
<h3 id="浏览器禁用cookie"><a href="#浏览器禁用cookie" class="headerlink" title="浏览器禁用cookie"></a>浏览器禁用cookie</h3><p>我们可以认为的设置浏览器禁用cookie，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。这就用到了<strong>URL重写</strong>和<a href="https://blog.csdn.net/thebesghost/article/details/1322255" target="_blank" rel="noopener">隐藏表单的方法</a>。</p>
<p>将sessionid附加在URL中，用分号隔开👇</p>
<p><img src="https://pic1.zhimg.com/80/v2-505f23eabd3400f97bf5e82bafd63911_hd.png" alt=""></p>
<p>或者将sessionid作为参数放在URL中👇</p>
<p><img src="https://pic3.zhimg.com/80/v2-cc7f76d3394b7a4a1379da7fed89224d_hd.png" alt=""></p>
<h3 id="cookie与session的不同"><a href="#cookie与session的不同" class="headerlink" title="cookie与session的不同"></a>cookie与session的不同</h3><ul>
<li>cookie存于客户端不太会给服务器造成压力，session存于服务器端，在高并发情况下容易给服务器造成压力。</li>
<li>cookie可能会被浏览器的程序窥探甚至修改，安全性不高；session在服务器端较安全。有关账号密码之类的隐私信息要先加密再存入cookie，又服务器端进行解密。</li>
<li>有效期不同，cookie可以设置一个很长的过期时间。但session不行，服务器会定时地清理超时的session。</li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/zhoucheng05_13/article/details/80530681" target="_blank" rel="noopener">https://blog.csdn.net/zhoucheng05_13/article/details/80530681</a></p>
<p><a href="https://juejin.im/post/5cd9037ee51d456e5c5babca" target="_blank" rel="noopener">https://juejin.im/post/5cd9037ee51d456e5c5babca</a>（这篇写的特好）</p>
<h2 id="HTTP协议中的编码和解码"><a href="#HTTP协议中的编码和解码" class="headerlink" title="HTTP协议中的编码和解码"></a>HTTP协议中的编码和解码</h2><h3 id="字符集与编码"><a href="#字符集与编码" class="headerlink" title="字符集与编码"></a>字符集与编码</h3><p><img src="https://pic4.zhimg.com/80/v2-78ff5d6d033da64ff06c3b10344d7e09_hd.png" alt=""></p>
<p>一套编码规范包括字库表、字符集和编码方式。</p>
<p>字库表里存储了该编码规范中所有可以显示的字符，gbk编码规范的字库表就包含了几乎所有的汉字，但是不包括法文、俄文，所以gbk不能显示法文俄文。在字库表里每个字符都有对应的二进制地址，而字符集就是这些地址的集合。比如说ASCII码中的字符集中，字母a对应的地址是65（二进制为01000001），根据这个地址就能显示字母a。字库表与字符集一一对应，相互转换。</p>
<p>直接拿二进制地址来显示字母是非常麻烦的而且很占空间，于是发明了一些算法来节省空间，这些算法被称作编码方式。</p>
<p>一套表码规范可以又多种编码方式，不同的编码方式又不同的使用场景。比如常见的编码方式utf-8，这是一种编码方式，它所对应的编码规范叫做Unicode。Unicode是一种编码规范，除了utf-8, 它还有utf-16、utf-32等编码方式。不同的编码方式节约的空间不一样。</p>
<p>总而言之就是，一个二进制数通过一种编码方式，转化成编码字符集中对应的地址，然后在字库表里找到这个地址对应的字符，最终显示给用户。</p>
<h3 id="常见的编码规范"><a href="#常见的编码规范" class="headerlink" title="常见的编码规范"></a>常见的编码规范</h3><p>常见的编码规范：ASCII、gbk、ISO-8859-1、Unicode等</p>
<p>ASCII码是最早产生的编码规范，一共包含了从00000000到01111111的128个字符，可以表示阿拉伯数字、英文大小写字母和一些简单的符号。每个字符占据的是<strong>一个字节（实际上使用7位）的空间</strong>。</p>
<p>gbk全称是汉字内码扩展规范。持国际标准ISO/IEC10646-1和国家标准GB13000-1中的全部中日韩汉字，并包含了BIG5编码中的所有汉字。它使用<strong>两个字节的空间</strong>大小来存储字符的地址。一般国内网站使用大量汉字的时候会使用gbk编码规范。</p>
<p>ISO-8859-1除了收录了ASCII码里的字符，还有西欧语言、泰语、阿拉伯语、希伯来语等等文字符号.。ISO-8859-1<strong>充分使用8位的空间大小，占一个字节的空间</strong>。MySQL的默认编码规范就是它。但是它不支持中文。</p>
<p>以上三种规范互相是不兼容的，国际标准化组织推出了一款全球性标准的编码规范——Unicode。Unicode包含了世界所有的字符，使用<strong>4字节空间地址</strong>。虽说Unicode使用4字节的空间大小收尽了所有的字符，但每个字符都要使用4字节的空间大小，这有些浪费存储空间。于是推出了几种编码方式，最广为人所用的就是utf-8，utf-8是一种<strong>变长</strong>字符编码方式，再强调一次，utf-8是编码方式不是编码规范。utf-8的优势在于，对于一个字节就可以表示的字符，Unicode采用ASCII编码，通常用的英文都是一个字节，中文就采用三个字节，虽然中文编码方面Unicode编码占的空间没有ASCII编码所占空间小，但是它胜在面向全世界。当然，我们需要根据具体的使用环境来选择不同的编码规范。</p>
<h3 id="乱码的由来"><a href="#乱码的由来" class="headerlink" title="乱码的由来"></a>乱码的由来</h3><p>使用错误的编码规范来进行编码和解码，都会产生乱码现象。</p>
<h3 id="URL的编码与解码"><a href="#URL的编码与解码" class="headerlink" title="URL的编码与解码"></a>URL的编码与解码</h3><p>URL是采用ASCII码字符集进行编码的，所以如果URL中含有非ASCII码字符集的字符，就要对其进行编码。另外，URL中有一些保留字，如“&amp;”，表示参数分隔符，如果想要在URL中使用这些保留字，就要进行编码。至于具体怎么编码，就要用到“百分号编码规范”（“%编码”规范）。</p>
<p>对URL中属于ASCII字符集的非保留字不做编码；对URL中的保留字需要取其ASCII内码，然后加上“%”前缀将该字符进行编码；对于URL中的非ASCII字符需要取其Unicode内码，然后加上“%”前缀将该字符进行编码。</p>
<p><img src="https://pic2.zhimg.com/v2-8c7bac3dcc754caa225e826a2f74da8d_r.jpg" alt=""></p>
<h2 id="HTTP协议之身份认证"><a href="#HTTP协议之身份认证" class="headerlink" title="HTTP协议之身份认证"></a>HTTP协议之身份认证</h2><p>HTTP是无状态的，即对于每一次请求都是一个全新的请求，服务器不保存上一次请求的信息，记不住请求者的信息。但是实际开发中，身份认证是非常重要的，有的HTTP请求只能允许部分人发起，因此需要身份认证。</p>
<p>常见的认证方式有：</p>
<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST认证（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
<h3 id="BASIC基本认证"><a href="#BASIC基本认证" class="headerlink" title="BASIC基本认证"></a>BASIC基本认证</h3><p>Basic身份认证，是HTTP 1.0中引入的认证方案之一。虽然方案比较古老，同时存在安全缺陷，但由于实现简单，至今仍有不少网站在使用它。</p>
<p><img src="https://pic4.zhimg.com/v2-4b2d93c38a1924ac8746c884b14ef6af_r.jpg" alt=""></p>
<p>工作原理：</p>
<p><img src="https://pic4.zhimg.com/v2-983ed96f06690c848061c1abdc8f41c7_r.jpg" alt=""></p>
<p>BASIC基本认证使用的是明文密码，安全性差。</p>
<h3 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h3><p>DIGEST认证同样使用质询/响应的方式，但不会向BASIC认证那样直接发送明文密码。服务器端会返回一个临时的质询码，客户端收到后会发送摘要以及由质询码计算得来的响应码，这比起明文base64编码来得安全。</p>
<p><img src="https://pic1.zhimg.com/v2-16fd13ed150171630d7ada72bf1860c4_r.jpg" alt=""></p>
<p>DIGEST认证提供了防止mi’ma被窃听的保护机制，但是没有防止用户伪装的保护机制。所以其安全性也不算高。</p>
<h3 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h3><p>SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自自己登录的客户端。</p>
<p>SSL安全性高，但是使用的成本高，一般是银行或者网银使用。</p>
<h3 id="基于表单的认证"><a href="#基于表单的认证" class="headerlink" title="基于表单的认证"></a>基于表单的认证</h3><p>基于表单的认证方法并不是在HTTP协议中定义的，使用由web应用程序各自实现基于表单的认证方式。通过cookie和session的方式来保持用户的状态。</p>
<p>这是最广泛使用的认证方法。</p>
<h2 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h2><p>HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP请求就结束了，是无连接的。所以就谈不上什么长连接短链接了，那么我们说的HTTP长连接短链接究竟是什么意思呢？</p>
<p><strong>HTTP的长连接和短链接本质上是TCP长连接和短链接。</strong></p>
<p>HTTP/1.0中，默认使用的是短链接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，结束后就中断。</p>
<p>HTTP/1.1起，默认使用长连接，用以保持连接特性。</p>
<p>访问百度首页：</p>
<p><img src="https://pic3.zhimg.com/v2-af381740b7676fbd8f89681cbb99c6ee_r.jpg" alt=""></p>
<p>打开开发者工具可以看到响应头里有<code>Connection：keep-alive</code>报文字段。这是一个长连接，用于传输数据的TCP/IP连接并没有断开，如果客户端再次访问这个网页，会继续使用这条已经建立的连接。注意，keep-alive不会永久保持，它也有一个保持时间，可以用apache等中间件进行设置。</p>
<p><img src="https://pic2.zhimg.com/v2-fff9f2850d504f3d129f3bec11d54fa1_r.jpg" alt=""></p>
<p>那些需要频繁请求的业务场景就需要用到长连接。目前大多数网站都默认使用长连接。</p>
<p>参考文章：<a href="https://www.cnblogs.com/0201zcr/p/4694945.html" target="_blank" rel="noopener">https://www.cnblogs.com/0201zcr/p/4694945.html</a>（写得很好）</p>
<h2 id="HTTP中介之代理proxy"><a href="#HTTP中介之代理proxy" class="headerlink" title="HTTP中介之代理proxy"></a>HTTP中介之代理proxy</h2><p><img src="https://pic4.zhimg.com/v2-7f176794f2dc6ce1f6cfe490853c9073_r.jpg" alt=""></p>
<p>比如常见的Charles和fiddler就是代理服务器软件。</p>
<h3 id="代理服务器的作用"><a href="#代理服务器的作用" class="headerlink" title="代理服务器的作用"></a>代理服务器的作用</h3><ul>
<li>翻墙（和vpn的原理还不一样，VPN的原理是隧道技术而非代理服务器）</li>
<li>抓包</li>
<li>匿名访问</li>
<li>儿童过滤器</li>
</ul>
<h3 id="使用代理服务器的安全问题"><a href="#使用代理服务器的安全问题" class="headerlink" title="使用代理服务器的安全问题"></a>使用代理服务器的安全问题</h3><p>代理服务器和抓包工具（比如Fiddler）都能看到http request中的数据。 如果我们发送的request中有敏感数据，比如用户名，密码，信用卡号码。这些信息都会被代理服务器看到。所以非常危险。 所以我们一般都是用HTTPS来加密Http request.  这样代理服务器就看不到里面的数据了。</p>
<p>参考文章：<a href="https://www.cnblogs.com/dhl-2013/p/3252986.html" target="_blank" rel="noopener">https://www.cnblogs.com/dhl-2013/p/3252986.html</a>（写得很好）</p>
<h2 id="HTTP中介之网关gateway"><a href="#HTTP中介之网关gateway" class="headerlink" title="HTTP中介之网关gateway"></a>HTTP中介之网关gateway</h2><p>网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。</p>
<p><strong>网关扮演的是“协议转换器”的角色。</strong></p>
<p> 可以用一个斜杠来分隔客户端和服务器端协议，并以此对网关进行描述：</p>
<p>&lt; 客户端协议 &gt;/&lt; 服务器端协议 &gt;</p>
<ul>
<li>服务器端网关（server-side gateway）通过 HTTP 与客户端对话，通过其他协议与服务器通信（HTTP/*）。</li>
<li>客户端网关（client-side gateway）通过其他协议与客户端对话，通过 HTTP 与服务器通信（*/HTTP）。</li>
</ul>
<h3 id="常见的几种网关"><a href="#常见的几种网关" class="headerlink" title="常见的几种网关"></a>常见的几种网关</h3><p><strong>1、 HTTP/*：服务器端Web网关</strong></p>
<p>　　请求流入原始服务器时，服务器端Web网关会将客户端HTTP请求转换为其他协议</p>
<p>　　在下图中，网关收到了一条对FTP资源的HTTP请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://ftp.irs.gov/pub/00-index.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.xiaohuochai.site/blog/HTTP_gateway4.jpg" alt="gateway4"></p>
<p>　　网关会打开一条到原始服务器FTP端口(端口 21)的FTP连接，通过FTP协议获取对象。网关会发送USER和PASS命令登录到服务器上去；发布CWD命令，转移到服务器上合适的目录中去；将下载类型设置为ASCII；用MDTM获取文档的最后修改时间；用PASV告诉服务器将有被动数据获取请求到达；用RETR请求进行对象获取；打开到FTP服务器的数据连接，服务器端口由控制信道返回，一旦数据信道打开了，就将对象内容回送给网关</p>
<p>　　完成获取之后，会将对象放在一条HTTP响应中回送给客户端</p>
<p>　　<strong>2、HTTP/HTTPS：服务器端安全网关</strong></p>
<p>　　一个组织可以通过网关对所有的输入Web请求加密，以提供额外的隐私和安全性保护。客户端可以用普通的HTTP浏览Web内容，但网关会自动加密用户的对话</p>
<p><img src="https://pic.xiaohuochai.site/blog/HTTP_gateway5.jpg" alt="gateway5"></p>
<p>　　<strong>3、HTTPS/HTTP：客户端安全加速器网关</strong></p>
<p>　　可以将HTTPS/HTTP网关作为安全加速器使用，这些HTTPS/HTTP网关位于Web服务器之前，通常作为不可见的拦截网关或反向代理使用。它们接收安全的HTTPS流量，对安全流量进行解密，并向Web服务器发送普通的HTTP请求</p>
<p><img src="https://pic.xiaohuochai.site/blog/HTTP_gateway6.jpg" alt="gateway6"></p>
<p>　　这些网关中通常都包含专用的解密硬件，以比原始服务器有效得多的方式来解密安全流量，以减轻原始服务器的负荷。这些网关在网关和原始服务器之间发送的是未加密的流量。所以，要谨慎使用，确保网关和原始服务器之间的网络是安全的</p>
<p>【资源网关】</p>
<p>　　最常见的网关——应用程序服务器，会将目标服务器与网关结合在一个服务器中实现。应用程序服务器是服务器端网关，与客户端通过HTTP进行通信，并与服务器端的应用程序相连</p>
<p><img src="https://pic.xiaohuochai.site/blog/HTTP_gateway7.jpg" alt="gateway7"></p>
<p>　　在上图中，两个客户端是通过HTTP连接到应用程序服务器的。但应用程序服务器并没有回送文件，而是将请求通过一个网关应用编程接口(Application Programming Interface, API)发送给运行在服务器上的应用程序</p>
<p>　　收到客户端A的请求，根据URI将其通过API发送给一个数码相机应用程序。 将得到的图片绑定到一条HTTP响应报文中，再回送给客户端，在客户端的浏览器中显示</p>
<p>　　客户端B的URI请求的是一个电子商务应用程序。客户端B的请求是通过服务器网关API发送给电子商务软件的，结果会被回送给浏览器。电子商务软件与客户端进行交互，引导用户通过一系列HTML页面来完成购物</p>
<p>参考文章：<a href="https://xiaohuochai.site/HTTP/structure/others.html" target="_blank" rel="noopener">https://xiaohuochai.site/HTTP/structure/others.html</a></p>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>参考文章：<a href="https://www.cnblogs.com/echolun/p/9419517.html" target="_blank" rel="noopener">https://www.cnblogs.com/echolun/p/9419517.html</a></p>
<p>如果没有缓存，客户端每次都要请求数据，浪费流量。同时，服务器每次都要提供查找、下载，请求用户基数如果比较大的话，服务器也会存在比较大的压力。客户端每次加载完后要进行页面渲染，用户体验显得特别差。</p>
<p>那么，我们可不可以将文件保存起来，这就需要做HTTP缓存。     </p>
<p>H<strong>TTP缓存主要针对样式文件(CSS)、JS文件、图片等更新频率不高的静态文件。</strong>所以，缓存不是缓存了一个HTTP请求的响应，更多是一些静态的资源文件。</p>
<p>在HTTP协议里面，更多通过请求头和响应头来实现。</p>
<h3 id="HTTP缓存头部字段"><a href="#HTTP缓存头部字段" class="headerlink" title="HTTP缓存头部字段"></a>HTTP缓存头部字段</h3><p><strong>Cache-Control：</strong></p>
<p>存在于请求头和响应头，是缓存控制字段。它是控制HTTP缓存的最高指令。</p>
<p><img src="https://pic4.zhimg.com/v2-e04ce39e4cb49751f44e4644451fde77_r.jpg" alt=""></p>
<p><strong>Expires：</strong></p>
<p>响应头字段，代表资源过期时间，有服务器返回提供，是HTTP/1.0的属性，在和max-age共存时，优先级要低。</p>
<p><strong>Last-Modified：</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
<p>响应头字段，表示资源最近一次的修改时间，由服务器告知浏览器。跟它经常一起使用的是另一个请求头字段<code>if-Modified-Since</code>。</p>
<p><strong>if-Modified-Since：</strong></p>
<p>请求头字段，也是表示资源最近一次的修改时间（实际上就是上次服务器返回的Last-Modified），由浏览器告知服务器，和<code>Last-Modified</code>是一对，它俩会进行比对。</p>
<p><strong>Etag：</strong></p>
<p>响应头字段，缓存资源标识，由服务器告知浏览器。</p>
<p><strong>if-None-Match：</strong></p>
<p>请求头字段，缓存资源标识，由浏览器告知服务器，（其实就是上次服务器给的Etag），和Etag是一对，它俩会进行对比。</p>
<h3 id="HTTP缓存工作方式"><a href="#HTTP缓存工作方式" class="headerlink" title="HTTP缓存工作方式"></a>HTTP缓存工作方式</h3><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><strong>Expires</strong></h4><p><strong>场景一：</strong>让服务器与浏览器约定一个文件过期时间——<strong>Expires</strong></p>
<p>浏览器：服务器，我要一个xxx.js文件，帮我找找，然后发给我。</p>
<p>服务器：次次找我要，烦死了。文件给你可以，我们约定一个时间(Expires)，时间没到就别来烦我了。返回了目标文件以及过期时间Expires。</p>
<p>Expires时间内，浏览器不会再向服务器要xxx.js文件而是使用本地缓存。Expires过期了，浏览器就又会重新发起请求了。但是有这么一种情况，Expires过期了，浏览器重新向服务器要这个xxx.js文件，但是，这个文件并没有发生任何修改。所以这种请求是浪费的。</p>
<h4 id="Last-Modified与if-Modified-Since"><a href="#Last-Modified与if-Modified-Since" class="headerlink" title="Last-Modified与if-Modified-Since"></a><strong>Last-Modified</strong>与<strong>if-Modified-Since</strong></h4><p><strong>场景二：</strong>让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比——<strong>Last-Modified</strong>与<strong>if-Modified-Since</strong></p>
<p>浏览器：服务器我要一个xxx.js文件，你找到了给我，顺便给我一个过期时间Expires，时间没到我保证不烦你。</p>
<p>服务器：OK，过期时间Expires我给你，另外再给你一个文件最新修改时间Last-Modified，到时候Expires过期了咱俩核对文件修改时间，对得上(说明文件未被改动)，你就别烦我。返回了xxx.js+Expires+Last-Modified。</p>
<p>模拟情况：浏览器在Expires过期后，向服务器发起了请求，服务器核对浏览器请求头的if-Modified-Since和自己服务器响应报文头的Last-Modified，发现是一样的，说明该目标文件没有被修改过，所以服务器响应报文会给浏览器返回304状态码，告知浏览器自上次访问以来资源并没有改变，浏览器接着使用本地缓存，不用浪费流量。</p>
<p><img src="https://pic3.zhimg.com/v2-650886977ac33ef888180368249106ae_r.jpg" alt=""></p>
<p>有了Expires和文件修改时间这双重机制，还是不够的。Expires可以在浏览器端被修改，不可靠。而Last-Modified和if-Modified-Since只能精确到秒，如果文件恰好在一秒内发生了修改，那么Last-Modified和if-Modified-Since是不可靠的，文件无法拿到最新的文件。</p>
<h4 id="Etag与If-None-Match"><a href="#Etag与If-None-Match" class="headerlink" title="Etag与If-None-Match"></a>Etag与If-None-Match</h4><p><strong>场景三：</strong>让服务器与浏览器在过期时间Expires+Last-Modified的基础上，增加一个文件内容唯一对比标识Etag与If-None-Match。Expires不稳定，再加一个max-age来加以代替。</p>
<p>浏览器：我要xxx.js文件</p>
<p>服务器：xxx.js我给你，过期时间Expires我也给你，再给你一个cache-control: max-age=60(单位秒)，Last-Modified我也给你，再加一个文件内容唯一标识Etag。</p>
<p>事实上有了<code>cache-control: max-age=</code>，Expires就没用了；有了Etag，Last-Modified就没用了；max-age和Etag的优先级是最高的。尽管如此，服务器很多情况下还是会将Expires和Last-Modified返回给浏览器。</p>
<p>模拟场景：浏览器在max-age的时间到了之后，向服务器发起了请求，服务器核对浏览器请求头的If-None-Match和自己服务器响应报文头的Etag，发现是一样的，说明该目标文件没有被修改过，所以服务器响应报文会给浏览器返回304状态码，告知浏览器自上次访问以来资源并没有改变，浏览器接着使用本地缓存，不用浪费流量。</p>
<p><img src="https://pic3.zhimg.com/v2-c3186628332d228b6676bc6ad9482cea_r.jpg" alt=""></p>
<p><strong>max-age和Expires的区别</strong></p>
<p>在用fiddler抓包的时候，发现不少网站同时设置了max-age和Expires，为毛要设置两个，功能不都差不多吗，两者区别是啥？</p>
<p>1.max-age是http1.1的属性，Expires是http1.0的属性，为了做到向下兼容，一般写两个。但如在1.1环境下，max-age优先级比Expires高。</p>
<p>2.max-age是相对过期时间，Expires是绝对过期时间。max-age在浏览器成功缓存文件后，只需相对请求成功之后的多长时间不再发起请求就好了，而Expires总是需要服务器返回一个精准的GMT格式的日期，并以这个日期为标准来判断缓存是否过期，想对就比较麻烦，所以才有了max-age这样的存在来代替它。</p>
<p>同理，no-cache和 Pargma也是这样的存在，一个是1.1的属性，一个是1.0，向下兼容，同时写了两个。</p>
<h3 id="缓存改进方案"><a href="#缓存改进方案" class="headerlink" title="缓存改进方案"></a>缓存改进方案</h3><p>Expires和max-age未过期的情况下，浏览器是无法主动感知到服务器文件变化的；服务器的文件变化了，浏览器的缓存时间还没到，浏览器就无法及时的更新文件。那么，如果我们改变了文件，那么如何让用户知道呢？</p>
<h4 id="1-md5-hash缓存"><a href="#1-md5-hash缓存" class="headerlink" title="1.md5/hash缓存"></a><strong>1.md5/hash缓存</strong></h4><p>通过<strong>不缓存html</strong>，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。</p>
<p>为什么这么做？实现原理是什么？</p>
<p>我们前面说的http缓存方案，服务器与浏览器的文件修改时间对比，文件内容标识对比，前提基础都是建立在<strong>两者文件路径完全相同</strong>的情况下。</p>
<p><strong>module/js/a-hash1.js</strong>与<strong>module/js/a-hash2.js</strong>是两个完全不同的文件，假想浏览器第一次加载页面，请求并缓存了<strong>module/js/a-hash1.js，</strong>第二次加载，文件指向变成了<strong>module/js/a-hash2.js，</strong>浏览器会直接重新请求<strong>a-hash2.js，因为</strong>这就是两个完全不同的文件，哪里还有什么http缓存文件对比，t通过这种做法，我们就可以从根本上解决过期时间没到浏览器无法主动请求服务器的问题。因此我们只需要在项目每次发布迭代将修改过的静态文件添加不同的MD5或hash标识就好啦。</p>
<p><strong>注意，这里不推荐缓存html文件(或许有更好的做法，欢迎留言)，这样每次html加载渲染都可以感知文件变化，反正文件没变还是使用本地缓存，文件名都变了说明修改过，重新请求缓存就好了。</strong></p>
<p>怎么改？一个个手动去修改？那不得累死。webpack提供了<strong>webpack-md5-hash插件</strong>，可以帮助开发者在项目发布时自动修改文件标识。</p>
<p>我们公司因为用的是fis3打包工具，这里使用的是<strong>fis3构建-文件指纹</strong>(搜文件指纹)，原理都差不多。</p>
<p><img src="https://images2018.cnblogs.com/blog/1213309/201808/1213309-20180812210442732-1599210158.png" alt="img"></p>
<h4 id="2-CDN缓存"><a href="#2-CDN缓存" class="headerlink" title="2.CDN缓存"></a><strong>2.CDN缓存</strong></h4><p>在文章开头cache-control相关值介绍中，提到了例如s-maxage代理服务器的概念，本人在整理http缓存相关知识点时，从同学口中了解到了也较为推荐的http缓存方案——CDN缓存，这里就作为一个拓展吧，正常的缓存还是推荐MD5缓存。</p>
<p><strong>2.1什么是CDN</strong></p>
<p>了解CDN缓存，先得知道什么是CDN，CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术(较为官方的说明)。</p>
<p>之前看到一个不错的例子，这里直接拿过来举例说说CDN。</p>
<p>假设多年前我们所在的城市只有一个火车站，每次春运，整个城市的人都得去这个火车站买票，人流量以及购票的需求可想而知有多大，为了缓解这个问题，城市的不同区，都出现了火车票代售点，这样每个区的人都可以就近买票了，火车站总站的压力就这样大大减轻了。</p>
<p>我们可以把每个区的售票点称之为CDN节点，也就是前面所说的代理服务器。简而言之，我们可以把CDN理解成浏览器与服务器之间的临时站点，它会替服务器处理一部分的浏览器请求，从而整理减轻总服务器的压力。</p>
<p>我们可以把CDN的价值归纳为：</p>
<p>1.CDN通过分流的形式，大大减轻源站的访问压力。</p>
<p>2.就像住的区比较偏远，每次买票要去城市中心，而这个区后来有了分站，火车票就可以就近购买一样。CDN也解决了跨地区访问问题，根本上为访问提供了加速。</p>
<p><strong>2.2什么是CDN缓存</strong></p>
<p><strong>CDN边缘节点缓存数据，当浏览器请求，CDN将代替源站判断并处理此处请求。</strong></p>
<p>日常请求对话</p>
<p>第一次请求</p>
<p>浏览器：服务器老哥，我需要a.js.</p>
<p>服务器：（恼羞成怒）文件我给我小弟CDN了，以后你要这个找CDN，别找我了。成功返回a.js给CDN，CDN进行缓存，同时CDN返回给浏览器，浏览器自己也进行了缓存(cache-control的值public就是用在这的)。</p>
<p>后续请求…</p>
<p>浏览器：服务器，我缓存时间到了，赶紧给我对比下文件，看看要不要重新返回给我。</p>
<p>CDN节点：打住打住，叫唤啥呢，我大哥比较忙，文件给我看看，请求被代理了。</p>
<p>情况1：CDN节点自己缓存的文件未过期，于是返回了304给浏览器，打回了这次请求。</p>
<p>情况2：CDN节点发现自己缓存的文件过期了，为了保险起见，自己发起请求给了服务器(源站)，成功拿回了最新数据，然后再交给与了浏览器。</p>
<p>其实说到这，CDN缓存的问题也跟前面的http缓存一样，CDN缓存时间不过期，浏览器始终被拦截，无法拿到最新的文件。</p>
<p>但是我们回归http缓存问题本质，缓存本身针对于更新频率不高的静态文件，其次，CDN缓存提供了分流以及访问加速其它优势条件。这里我问过同学，得到的信息是，CDN类似一个平台，是可以通过登录，手动更新CDN缓存的，变相解决了浏览器缓存无法手动控制的问题。</p>
<h3 id="浏览器操作对HTTP缓存的影响"><a href="#浏览器操作对HTTP缓存的影响" class="headerlink" title="浏览器操作对HTTP缓存的影响"></a>浏览器操作对HTTP缓存的影响</h3><p>1.<strong>浏览器地址栏回车，或者点击跳转按钮，前进，后退，新开窗口</strong>，这些行为，会让Expires，max-age生效，也就是说，这几种操作下，浏览器会判断过期时间，再考虑要不要发起请求，当然Last-Modified和Etag也有效。</p>
<p>2.<strong>F5刷新浏览器，或者使用浏览器导航栏的刷新按钮</strong>，这几种，会忽略掉Expires，max-age的限制，强行发起请求，Last-Modified和Etag在这种情况下也有效。</p>
<p>3<strong>.CTRL+F5</strong>是强制请求，所有缓存文件都不使用，全部重新请求下载，因此Expires，max-age，Last-Modified和Etag全部失效。</p>
<p><img src="https://images2018.cnblogs.com/blog/1213309/201808/1213309-20180812215938593-1709664851.png" alt="img"></p>
<h3 id="强缓存与协商性缓存-弱缓存"><a href="#强缓存与协商性缓存-弱缓存" class="headerlink" title="强缓存与协商性缓存(弱缓存)"></a><strong>强缓存与协商性缓存(弱缓存)</strong></h3><p>了解了上面不同浏览器行为对http缓存的不同影响，理解强缓存与协商性缓存就很容易了。</p>
<p><strong>强缓存：</strong>不发起http请求，直接使用本地缓存，比如浏览器地址栏回车，使用浏览器的刷新按钮，在Expires或max-age生效的情况下，触发的都是强缓存。</p>
<p><strong>协商性缓存(弱缓存)：</strong>在使用本地缓存前，先与服务器协商，核对缓存文件是否为最新。比如设置了cache-control=no-cache，不管你做任何操作，都会发起请求，这一类就是协商性缓存了。</p>
<h2 id="内容协商机制"><a href="#内容协商机制" class="headerlink" title="内容协商机制"></a>内容协商机制</h2><p>举个例子，同样是访问<a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a>，在中国显示的就是中文的，在英国就显示英文的，在法国就显示法文的。</p>
<p>一个URL常常要代表若干个不同的资源，例如那种多种语言显示的网站站点，希望给英语用户提供英文版，给中文用户提供给中文版，这就需要用到内容协商机制。</p>
<p><strong>内容协商机制</strong>指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。通过这种方法，同一个URL就可以代表不同的网站。</p>
<p>一共有三种方式来决定哪个页面最适合当前客户端。</p>
<p>详见<a href="https://www.cnblogs.com/supersnowyao/p/8593828.html" target="_blank" rel="noopener">https://www.cnblogs.com/supersnowyao/p/8593828.html</a>这篇文章讲得很好</p>
<h2 id="补充一下：请求体-响应体和实体的区别"><a href="#补充一下：请求体-响应体和实体的区别" class="headerlink" title="补充一下：请求体/响应体和实体的区别"></a>补充一下：请求体/响应体和实体的区别</h2><p><a href="https://blog.csdn.net/u012422829/article/details/51570652" target="_blank" rel="noopener">https://blog.csdn.net/u012422829/article/details/51570652</a></p>
<h2 id="断点续传和多线程分块下载"><a href="#断点续传和多线程分块下载" class="headerlink" title="断点续传和多线程分块下载"></a>断点续传和多线程分块下载</h2><p>有时用户上传/下载文件需要历时数小时，万一线路中断，不具备断点续传的 HTTP/FTP 服务器或下载软件就只能从头重传，比较好的 HTTP/FTP 服务器或下载软件具有断点续传能力，允许用户从上传/下载断线的地方继续传送，这样大大减少了用户的烦恼。</p>
<p>常见的支持断点续传的上传/下载软件：QQ 旋风、迅雷、快车、电驴、酷6、土豆、优酷、百度视频、新浪视频、腾讯视频、百度云等。</p>
<p><strong>断点续传：</strong>指的是在上传/下载时，将任务（一个文件或压缩包）人为的<strong>划分为几个部分</strong>，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。</p>
<p>HTTP通过在Header里两个参数实现的，客户端发请求时对应的时Range，服务器端响应时对应的时Content-Range。无论是断点续传还是多线程分块下载，如果续传成功，返回206并返回剩余的文件内容；如果文件有变动，返回200状态码和新文件的内容。这是HTTP协议里自带的规则。</p>
<p>Range：</p>
<p>用于请求头，指定第一个字节的位置和最后一个字节的位置，一般格式为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: (unit=first byte pos)-[last byte pos]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=0-499   //表示第0到第499字节范围的内容</span><br><span class="line">Range: bytes=500-999 //表示第500到第999字节范围的内容</span><br><span class="line">Range: bytes=-500    //表示最后500个字节的内容</span><br><span class="line">Range: bytes=500-    //表示从第500字节开始到文件结束的部分</span><br><span class="line">Range: bytes=500-600,601-999    //分块了，分别表示表示第500到第600字节范围的内容和表示第601到第999字节范围的内容</span><br></pre></td></tr></table></figure>
<p><strong>Content-Range：</strong></p>
<p>用于响应头中，在发出带Range的请求后，服务器会在content-Range头部返回当前接收的范围和文件总大小。一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes(unit first byte pos) - [last byte pos]/[entity length]</span><br></pre></td></tr></table></figure>
<p>而在响应完成后，返回的响应头内容也不同：</p>
<ul>
<li>HTTP/1.1 200 OK （不使用断点续传方式）</li>
<li>HTTP/1.1 206 Partial Content （使用断点续传）</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-283bc5b378a63a0bc07099c824680c6b_r.jpg" alt=""></p>
<p> 多线程分块下载也是类似于上述这种断点续传的过程，只不过断点续传是被动的增量下载，而多线程下载是主动的分片下载，但是都是使用的Range的这种模式</p>
<h2 id="初识HTTP与HTTPS"><a href="#初识HTTP与HTTPS" class="headerlink" title="初识HTTP与HTTPS"></a>初识HTTP与HTTPS</h2><p>参考文章：<a href="https://www.jianshu.com/p/30b8b40a671c" target="_blank" rel="noopener">https://www.jianshu.com/p/30b8b40a671c</a></p>
<p>实际上HTTP和HTTPS可以算是两种不同的网络传输协议，虽然就差一个字母，但是本质确实大不相同。</p>
<p><img src="https://pic1.zhimg.com/80/v2-274d4f6d5a04c2dcde944d6f4cfdc73c_hd.jpg" alt=""></p>
<p>HTTP协议是应用层的协议，以请求和响应的方式在客户端和服务端进行通信。HTTP协议不够安全，因为其是以明文方式进行传输的，不做任何加密。在HTTP传输的过程中可能被中间人截获并篡改了信息。</p>
<p>针对明文传输的缺点，我们可以对明文进行加密，加密分两种：一种叫对称加密，另一种叫非对称加密。</p>
<p>对称加密也称密钥加密，即加密和解密使用的都是同一个密钥。而非对称加密也叫公钥加密，即加密和解密使用不同的密钥。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f44db3085c661cd5ed65ec091333e45e_hd.jpg" alt="img"></p>
<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>针对上述问题，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>
<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>
<p>在小灰和小红建立通信的时候，小红首先把自己的公钥Key1发给小灰：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f3ab1daafe9daa179a15d447467c7aed_hd.jpg" alt="img"></p>
<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥Key2（key2用于对称加密通信数据），并且用刚才接收的公钥Key1对Key2进行加密，发送给小红：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d2daf8ba5615dc9d427a6fe3d20d1031_hd.jpg" alt="img"></p>
<p>小红利用自己非对称加密的私钥，解开了公钥Key1的加密，获得了Key2的内容。从此以后，两人就可以利用Key2进行对称加密的通信了。</p>
<p><img src="https://pic4.zhimg.com/80/v2-d3ecc2fa78ccaed37c478b4055198ceb_hd.jpg" alt="img"></p>
<p>在通信过程中，即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密。</p>
<p>  <strong>但是，这还不是最安全的！</strong></p>
<p>中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9a458296959c052b026560a5892368f2_hd.jpg" alt="img"></p>
<p>小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。</p>
<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。</p>
<p><img src="https://pic2.zhimg.com/80/v2-5123c1a68be44a178c6f6c1543dfc3f1_hd.jpg" alt="img"></p>
<p>这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。</p>
<h3 id="引入证书"><a href="#引入证书" class="headerlink" title="引入证书"></a>引入证书</h3><p>上述情况的中间人太狡猾了，难道再把公钥进行一次加密吗？这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>
<p>这时候，我们有必要引入第三方，一个<strong>权威的证书颁发机构（CA）</strong>来解决。</p>
<p>到底什么是证书呢？证书包含如下信息：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d67c298621ff7b0993bf40fada27f573_hd.jpg" alt="img"></p>
<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>
<p>流程如下：</p>
<p>1.作为服务端的小红，首先把自己的<strong>公钥发给证书颁发机构</strong>，向证书颁发机构<strong>申请证书</strong>。</p>
<p><img src="https://pic3.zhimg.com/80/v2-e94e6b7dc1376c799ae3e1aadc469ea2_hd.jpg" alt="img"></p>
<p>2<strong>.证书颁发机构自己也有一对公钥私钥</strong>。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把CA证书发送给了服务端小红。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4a394ede38b526839ce8ada8643934c6_hd.jpg" alt="img"></p>
<p>3.当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>
<p><img src="https://pic3.zhimg.com/80/v2-35e555a8c74fbddc32ff610819480936_hd.jpg" alt="img"></p>
<p>4.小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，<strong>各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥</strong>。所以小灰只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>
<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥Key1。</p>
<p><img src="https://pic3.zhimg.com/80/v2-123b8861cdefd9a322760ec7591f1cde_hd.jpg" alt="img"></p>
<p>5.像之前一样，小灰生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给小红。</p>
<p><img src="https://pic3.zhimg.com/80/v2-e8288a959d6fbd5019fa91c0e0b370f2_hd.jpg" alt="img"></p>
<p>6.最后，小红用自己的私钥解开加密，得到对称加密密钥Key2。于是两人开始用Key2进行对称加密的通信。</p>
<p><img src="https://pic1.zhimg.com/80/v2-4e1c4a6836c8a4b0c7511a0d21710664_hd.jpg" alt="img"></p>
<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢？</p>
<p><img src="https://pic3.zhimg.com/80/v2-98502876ee22cbe643e3cd2a6ad74c2e_hd.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-761d4917160cc15f06056f7043a84307_hd.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-abd130a15c5ba261a42f93add277948f_hd.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-0473074a3253131c0ad3ef4902cb2fb8_hd.jpg" alt="img"></p>
<p>这就是HTTPS的主题思想，HTTPS在HTTP协议的基础上增加了SSL安全层，上述的一系列认证流程就是在SSL层中完成的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-3db9b326b9d31745229a26a877a1308c_hd.jpg" alt="img"></p>
<p>注：最新推出的TLS协议，是SSL 3.0协议的升级版，和SSL协议的大体原理是相同的。</p>
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/57142784" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57142784</a></p>
<h2 id="HTTPS协议概述"><a href="#HTTPS协议概述" class="headerlink" title="HTTPS协议概述"></a>HTTPS协议概述</h2><p>HTTPS可以认为是HTTP+TLS 。 TLS是传输层加密协议，它的前身是SSL协议。</p>
<h3 id="HTTPS的功能"><a href="#HTTPS的功能" class="headerlink" title="HTTPS的功能"></a>HTTPS的功能</h3><ul>
<li>内容加密<ul>
<li>非对称密钥加密</li>
<li>对称内容加密</li>
</ul>
</li>
<li>身份认证<ul>
<li>数字证书</li>
</ul>
</li>
<li>数据完整性</li>
</ul>
<h3 id="HTTPS使用成本"><a href="#HTTPS使用成本" class="headerlink" title="HTTPS使用成本"></a>HTTPS使用成本</h3><ul>
<li>证书费用以及更新维护成本<ul>
<li>事实上现在不少证书费用都很便宜甚至免费，当然越贵的越安全</li>
</ul>
</li>
<li>HTTPS降低了用户访问的速度<ul>
<li>对了一层对SSL/TLS的访问，所以速度会变慢</li>
<li>但是通过合理的优化，使用HTTPS的速度是可以不逊色于HTTP的</li>
</ul>
</li>
<li>消耗CPU资源，需要增加大量机器<ul>
<li>前面提到的非对称密钥交换、对称的加解密，这很消耗cpu资源，需要其大量的计算</li>
<li>当然，只要进行合理的优化，该机器成本也可以得到较好的控制</li>
</ul>
</li>
</ul>
<p>实际上，HTTPS的使用成本大体上是可控的，使用HTTPS是大势所趋。</p>
<h3 id="HTTPS对性能的影响"><a href="#HTTPS对性能的影响" class="headerlink" title="HTTPS对性能的影响"></a>HTTPS对性能的影响</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 协议交互所增加的往返时延RTT</span><br><span class="line">- 加解密相关的计算耗时</span><br></pre></td></tr></table></figure>
<p>在计算机网络中，RTT（往返时延）是一个非常重要的指标。RTT表示：从发送端发送数据开始，到发送端收到来自接收端的确认，在这个过程中总共经过的时延。这也是影响我们网络访问速度的一个重要因素。</p>
<p>具体内容详见参考文章：<a href="http://blog.itpub.net/31557835/viewspace-2219412/" target="_blank" rel="noopener">http://blog.itpub.net/31557835/viewspace-2219412/</a></p>
<h3 id="HTTPS常见问答"><a href="#HTTPS常见问答" class="headerlink" title="HTTPS常见问答"></a>HTTPS常见问答</h3><p><a href="https://developer.baidu.com/resources/online/doc/security/https-faq.html" target="_blank" rel="noopener">https://developer.baidu.com/resources/online/doc/security/https-faq.html</a></p>
<h2 id="HTTP的瓶颈"><a href="#HTTP的瓶颈" class="headerlink" title="HTTP的瓶颈"></a>HTTP的瓶颈</h2><p>影响HTTP网络请求的两个因素： <strong>带宽</strong>  和  <strong>延迟</strong></p>
<p>以前的网速慢，带宽只有几十兆、一百兆，所以带宽曾经一度是影响HTTP网络请求的一个重大瓶颈，但现在的网速带宽已经非常快了，特别是移动互联网4G5G的到来，带宽越来越不成为影响HTTP网络请求的障碍。那么，就剩下延迟了。</p>
<p><strong>带宽：</strong>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，以前的网速慢，带宽只有几十兆、一百兆，所以带宽曾经一度是影响HTTP网络请求的一个重大瓶颈，但现在的网速带宽已经非常快了，特别是移动互联网4G5G的到来，带宽越来越不成为影响HTTP网络请求的障碍。那么，就剩下延迟了</p>
<p><strong>延迟：</strong></p>
<ul>
<li><p>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p>
</li>
<li><p>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p>
</li>
<li><p>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p>
</li>
</ul>
<h2 id="HTTP的缺陷"><a href="#HTTP的缺陷" class="headerlink" title="HTTP的缺陷"></a>HTTP的缺陷</h2><ul>
<li><p>一条连接上只可发送一个请求</p>
<p>单路连接 请求低效<br>HTTP 协议的最大弊端就是每个 TCP 连接只能对应一个 HTTP 请求，即每个 HTTP 连接只请求一个资源，浏览器只能通过建立多个连接来解决。此外在 HTTP 中对请求是严格的先入先出（FIFO）进行的，如果中间某个请求处理时间较长会阻塞后面的请求</p>
</li>
<li><p>请求只能从客户端开始。客户端不可以接收除响应外的指令。客户端无法及时的主动的感知到服务器文件的更新。</p>
</li>
<li><p>请求/响应头部不经压缩就发送</p>
</li>
<li><p>HTTP 头冗余<br>HTTP 头在同一个会话里是反复发送的，中间的冗余信息，比如 User-Agent、Host 等不需要重复发送的信息也在反复发送，浪费带宽和资源。</p>
</li>
<li><p>非强制压缩发送</p>
</li>
</ul>
<p>（这部分要再看一下视频最好）</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>参考文章：</p>
<p><a href="https://blog.csdn.net/u012654882/article/details/54576693" target="_blank" rel="noopener">https://blog.csdn.net/u012654882/article/details/54576693</a></p>
<h3 id="单工、半双工和全双工"><a href="#单工、半双工和全双工" class="headerlink" title="单工、半双工和全双工"></a>单工、半双工和全双工</h3><p>   在网络的领域内，单工、半双工、全双工是经常会遇见的名称，下面简单的讲述一下他们的区别。</p>
<pre><code>单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。

半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。

全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。
</code></pre><p>websocket是全双工的。</p>
<h3 id="websocket建立握手"><a href="#websocket建立握手" class="headerlink" title="websocket建立握手"></a>websocket建立握手</h3><p><strong>WebSocket是HTML5出的东西（协议）</strong>，Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解</p>
<p><img src="data:image/png;base64,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" alt=""></p>
<p>有交集，但是并不是全部。</p>
<p>Websocket是一个<strong>持久化</strong>的协议，相对于HTTP这种<strong>非持久</strong>的协议来说。HTTP是不支持持久连接的（长连接，循环连接的不算）。简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。<br>1) HTTP的生命周期通过Request来界定，也就是一个Request一个Response，那么<strong>在</strong>HTTP1.0<strong>中</strong>，这次HTTP请求就结束了。<br>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。<br>但是请记住 Request = Response ，在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是<strong>被动</strong>的，不能主动发起。</p>
<p>Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。</p>
<p>在握手阶段是一样的：</p>
<p>首先我们来看个典型的Websocket握手</p>
<p><img src="https://pic1.zhimg.com/v2-c91c2ee4afd3dbf92199aba00e84eae0_r.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>
<p>熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。</p>
<p>我会顺便讲解下作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>这个就是Websocket的核心了，告诉Apache、Nginx等服务器：</p>
<p>注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>首先，Sec-WebSocket-Key 是一个Base64encode的值，这个是浏览器随机生成的，告诉服务器：“不要忽悠窝，我要验证尼是不是真的是Websocket助理。”</p>
<p>然后，Sec_WebSocket-Protocol是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：</p>
<p>今晚我要服务A，别搞错啦~</p>
<p>最后，Sec-WebSocket-Version 是告诉服务器所使用的WebsocketDraft（协议版本），在最初的时候，Websocket协议还在 Draft阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用的一个协议版本。</p>
<p>然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<p>这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>依然是固定的，告诉客户端即将升级的是Websocket协议，而不是其他乱七八糟的协议。</p>
<p>然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的Sec-WebSocket-Key。服务器：“好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。”</p>
<p>后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。</p>
<p>至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。</p>
<h3 id="Ajax轮询和long-poll长轮询"><a href="#Ajax轮询和long-poll长轮询" class="headerlink" title="Ajax轮询和long poll长轮询"></a>Ajax轮询和long poll长轮询</h3><p>HTTP协议下，请求只能从客户端开始，客户端不可以接收除响应外的指令。<strong>客户端无法及时的主动的感知到服务器文件的更新。</strong>所以要想办法监听服务器端文件的更新情况。因此有了一些优化处理方式：一个是<strong>Ajax轮询</strong>，另一个叫<strong>long poll(其实就是长轮询)</strong>。 </p>
<p>  首先是 <strong>ajax轮询</strong> ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。<br>场景再现：<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有。。（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：你好烦啊，没有啊。。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：好啦好啦，有啦给你。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：。。。。。没。。。。没。。。没有（Response） —- loop</p>
<p><strong>long poll</strong><br>long poll 其实原理跟 ajax轮询差不多，都是采用轮询的方式，不过采取的是<strong>阻塞模型（一直打电话，没收到就不挂电话）</strong>，也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。<br>场景再现<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）<br>服务端：额。。 等待到有消息的时候。。来 给你（Response）<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</p>
<p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，<strong>被动性</strong>。<br>何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。<br>简单地说就是，服务器不会、不能主动发起连接，但是上司有命令，如果有客户来，不管多么累都要好好接待。</p>
<p>说完这个，我们再来说一说上面的<strong>缺陷</strong><br>从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。<br>ajax轮询 需要服务器有很快的处理速度和资源。（速度）<br>long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）<br>所以ajax轮询 和long poll 都有可能发生这种情况👇：</p>
<p>客户端：啦啦啦啦，有新信息么？<br>服务端：忙死啦，请稍后再试（503 Server Unavailable）<br>客户端：。。。。好吧，啦啦啦，有新信息么？<br>服务端：忙死啦，请稍后再试（503 Server Unavailable）<br>客户端：<img src="https://pic1.zhimg.com/7c0cf075c7ee4cc6cf52f4572a4c1c10_b.jpg" alt="WebSocket与http的区别，以及它的原理--"></p>
<p>-————————-</p>
<h3 id="webSocket解决方案"><a href="#webSocket解决方案" class="headerlink" title="webSocket解决方案"></a>webSocket解决方案</h3><p><strong>言归正传，我们来说Websocket吧</strong><br>通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。<br>一种需要更快的速度，一种需要更强的并发处理能力。<br>哦对了，忘记说了HTTP还是一个状态协议。<br>通俗的说就是，服务器因为每天要接待太多客户了，是个<strong>健忘鬼</strong>，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。</p>
<p>  所以在这种情况下出现了，Websocket出现了。<br>他解决了HTTP的这几个难题。<br>首先，<strong>被动性</strong>，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。<br>所以上面的情景可以做如下修改：<br>客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17   （HTTPRequest）<br>服务端：ok，确认，已升级为Websocket协议（   HTTP Protocols Switched）<br>客户端：麻烦你有信息的时候推送给我噢。。<br>服务端：ok，有的时候会告诉你的。<br>服务端：balabalabalabala<br>服务端：balabalabalabala<br>服务端：balabalabalabala</p>
<p>就变成了这样，只需要经过<strong>一次HTTP请求</strong>，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）<br><strong>这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。</strong><br>那么为什么他会解决服务器上消耗资源的问题呢？<br>其实我们所用的程序是要经过两层代理的，即<strong>HTTP协议在Nginx等服务器的解析下</strong>，然后再传送给相应的<strong>Handler（PHP等）</strong>来处理。<br>简单地说，我们有一个非常快速的接<strong>线员（Nginx）</strong>，他负责把问题转交给相应的<strong>客服（Handler）</strong>。<br>本身<strong>接线员基本上速度是足够的</strong>，但是每次都卡在<strong>客服（Handler）</strong>了，老有<strong>客服</strong>处理速度太慢。，导致客服不够。<br>Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持<strong>久连接</strong>，有信息的时候客服想办法通知接线员，然后<strong>接线员</strong>在统一转交给客户。<br>这样就可以解决客服处理速度过慢的问题了。</p>
<p>同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要<strong>重新传输identityinfo（鉴别信息）</strong>，来告诉服务端你是谁。<br>虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的<strong>处理时间</strong>，而且还会在网路传输中消耗<strong>过多的流量/时间。</strong><br>但是Websocket只需要<strong>一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中</strong>，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identityinfo的信息。<br>同时由<strong>客户主动询问</strong>，转换为<strong>服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。）</strong>，没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的<strong>客服（Handler）</strong>了<br>-——————-<br>至于怎么在不支持Websocket的客户端上使用Websocket。。答案是：<strong>不能</strong><br>但是可以通过上面说的 long poll 和 ajax 轮询来 <strong>模拟出类似的效果</strong>  </p>
<p>WebSocket 是类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p>
<p>总的来说，websocket的特点是(1) 全双工通信、(2)减少通信量。</p>
<p>具体的websocket使用见<a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>
<h2 id="SPDY协议"><a href="#SPDY协议" class="headerlink" title="SPDY协议"></a>SPDY协议</h2><p>参考文章：<a href="http://www.geekpark.net/news/158198" target="_blank" rel="noopener">http://www.geekpark.net/news/158198</a></p>
<p>这篇参考文章写的时候，作者还是很看好spdy的，认为其会有一个很好的前景，但事实上，spdy还没推广就被HTTP/2.0给取代了，谷歌也宣布放弃了spdy转投HTTP/2.0。</p>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>参考文章：</p>
<p><a href="https://segmentfault.com/a/1190000016656529#item-5-2" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016656529#item-5-2</a></p>
<p><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/#prettyPhoto" target="_blank" rel="noopener">http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/#prettyPhoto</a></p>
<p><a href="https://www.zhihu.com/question/34074946/answer/75364178" target="_blank" rel="noopener">https://www.zhihu.com/question/34074946/answer/75364178</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTP/2（超文本传输协议第2版，最初命名为HTTP2.0），是HTTP协议的第二个主要版本。HTTP/2是HTTP协议自1999年HTTP1.1发布后的首个更新，主要基于SPDY协议。<br>HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 二进制传输（核心）</span><br><span class="line">- 首部压缩</span><br><span class="line">- 多路复用</span><br><span class="line">- 请求优先级</span><br><span class="line">- 服务器推送</span><br></pre></td></tr></table></figure>
<h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><h4 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h4><p><strong>HTTP2.0性能增强的核心：二进制分帧</strong><br>    HTTP 2.0最大的特点： 不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段，等等这些核心概念上一如往常，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。<br>既然又要保证HTTP的各种动词，方法，首部都不受影响，那就需要<strong>在应用层(HTTP2.0)和传输层(TCP or UDP)之间增加一个二进制分帧层。</strong><br>     在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中<strong>HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</strong></p>
<p><img src="https://img-blog.csdn.net/20180912153834839?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAyMzA3OTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>    然后，HTTP 2.0 通信都在<strong>一个连接</strong>上完成，这个连接可以<strong>承载任意数量的双向数据流</strong>。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p>
<p>说到这儿，可能会有人要说了，<em>但是那样，所有的二进制帧都会带上Headers帧，这是多大的数据冗余传送啊，性能会受到影响吧…</em>。  事实上，针对这一点，HTTP2.0做了<strong>首部压缩处理</strong></p>
<h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>​    HTTP 2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送; 通信期间几乎不会改变的通用键-值对(用户代理、可接受的媒体类型,等等)只 需发送一次。事实上, 如果请求中不包含首部(例如对同一资源的轮询请求),那么 首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。<br>    如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP 2.0 的连接存续期内始终存在,由客户端和服务器共同渐进地更新 。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>众所周知 ，在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」。在HTTP1.0中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。</p>
<p>该图总结了不同浏览器对该限制的数目。</p>
<p><img src="https://pic3.zhimg.com/faedeb3dae59455f6520d6a5dbf436e5_r.jpg" alt=""></p>
<p>这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。</p>
<p><strong>HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。</strong><br>帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。<br>所谓<strong>多路复用</strong>，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。</p>
<p>多路复用有两个基本点：1、所有的HTTP2.0请求都在一个TCP链接上；2、并行双向字节流的请求和响应。</p>
<h4 id="所有的-HTTP2-0-的请求都在一个-TCP-链接上"><a href="#所有的-HTTP2-0-的请求都在一个-TCP-链接上" class="headerlink" title="所有的 HTTP2.0 的请求都在一个 TCP 链接上"></a>所有的 HTTP2.0 的请求都在一个 TCP 链接上</h4><p>而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的<strong>请求-响应</strong>消息，这也是继承自spdy协议。 </p>
<p><img src="https://pic3.zhimg.com/80/b1e608ddb7493608efea3e76912aabe1_hd.jpg" alt=""></p>
<p>因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上。</p>
<p><img src="https://segmentfault.com/img/bVbgpF3?w=494&amp;h=138" alt="图片描述"></p>
<p>HTTP2.0 所有通信都是在一个 TCP 连接上完成。HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应 着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。就好比，我请求一个页面 <a href="http://www.qq.com。页面上所有的资源请求都是客户端与服务器上的一条" target="_blank" rel="noopener">http://www.qq.com。页面上所有的资源请求都是客户端与服务器上的一条</a> TCP 上请求和响应的！</p>
<p>​    <strong>有关注 TCP 性能的同学就会知道，HTTP 性能的关键在于低延迟而不是高带宽！</strong>大多数 HTTP 连接的时间都很短，而且是突发性的，但 <strong>TCP 只在长时间连接传输大块数据时效率才最高</strong>。HTTP 2.0 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<p>​    同时，单链接多资源的方式，使到至上而下的层面都得到了好处：</p>
<ol>
<li>可以减少服务链接压力, 内存占用少了, 连接吞吐量大了</li>
</ol>
<p>​    2. 由于 TCP 连接减少而使网络拥塞状况得以改观;</p>
<p>​    3. 慢启动时间减少, 拥塞和丢包恢复速度更快。</p>
<p> <strong>补充：</strong>TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。</p>
<p><strong>也就是说，“资源合并减少请求” 的优化手段对于 HTTP2.0 来说是没有效果的，只会增大无用的工作量而已。</strong></p>
<h4 id="并行双向字节流的请求和响应"><a href="#并行双向字节流的请求和响应" class="headerlink" title="并行双向字节流的请求和响应"></a>并行双向字节流的请求和响应</h4><p>在 HTTP2.0 上，客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。注意，同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送 stream，也可以一边接收者服务器的响应，而服务器那端同理。</p>
<p><a href="http://www.alloyteam.com/wp-content/uploads/2015/03/stream.jpg" target="_blank" rel="noopener"><img src="http://www.alloyteam.com/wp-content/uploads/2015/03/stream.jpg" alt="stream"></a></p>
<p>把 HTTP 消息分解为独立的帧, 交错发送, 然后在另一端重新组装是 HTTP 2.0 最 重要的一项增强。事实上, 这个机制会在整个 Web 技术栈中引发一系列连锁反应, 从而带来巨大的性能提升, 因为:</p>
<ul>
<li><p>可以并行交错地发送请求, 请求之间互不影响;</p>
</li>
<li><p>可以并行交错地发送响应, 响应之间互不干扰;</p>
</li>
<li><p>只使用一个连接即可并行发送多个请求和响应;</p>
</li>
<li><p>消除不必要的延迟, 从而减少页面加载的时间;</p>
</li>
</ul>
<p><strong>那么也就是说 “域名分区” 这种优化手段对于 HTTP2.0 是无用的，因为资源都是并行交错发送，且没有限制，不需要额外的多域名并行下载。</strong></p>
<p>“既然所有资源都是并行交错发送，会不会出现这样的情况 【浏览器明明在等关键的 CSS 和 JS，你 TMD 的服务器还在发送图片】” ？？这就要说到HTTP2.0的请求优先级特性了。</p>
<h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>每个 HTTP2.0 流里面有个<strong>优先值</strong>，这个优先值确定着客户端和服务器处理不同的流采取不同的优先级策略，<strong>高优先级的流都应该优先发送</strong>，但又<strong>不会绝对地遵守</strong>，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。分配处理资源和客户端与服务器间的带宽，<strong>不同优先级的混合也是必须的</strong>。</p>
<p>“有了优先级，<strong>HTTP2.0 根本不会发生【浏览器明明在等关键的 CSS 和 JS，你 TMD 的服务器还在发图】</strong>” </p>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p><img src="https://pic3.zhimg.com/v2-85da1ac1cd92134019fbcfbe7161257e_r.jpg" alt=""></p>
<p> HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以<strong>主动地向客户端推送额外的资源，而无需客户端明确地请求</strong>。</p>
<p>当浏览器请求一个 html，服务器其实大概知道你是接下来要请求资源了，而不需要等待浏览器得到 html 后解析页面再发送资源请求。使用服务器推送的资源的方式更加高效，因为客户端还可以缓存起来（比如一开始向服务器请求的时候只请求了style.css，而服务器不仅给了style.css还主动返回了style.js，那么客户端就先缓存起来了，到要使用到style.js的时候很高兴的发现不用向服务端发起请求了，本地缓存就有！）。</p>
<h2 id="WebDAV（了解）"><a href="#WebDAV（了解）" class="headerlink" title="WebDAV（了解）"></a>WebDAV（了解）</h2><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可<strong>对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统</strong>。它作为扩展 HTTP/1.1 的协议定义在 RFC4918。多应用于坚果云网盘、wps、office等。</p>
<p>除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。</p>
<p>使用 HTTP/1.1 的 PUT 方法和 DELETE 方法，就可以对 Web 服务器上的文件进行创建和删除操作。可是出于安全性及便捷性等考虑，一般不使用。</p>
<h3 id="扩展-HTTP-1-1-的-WebDAV"><a href="#扩展-HTTP-1-1-的-WebDAV" class="headerlink" title="扩展 HTTP/1.1 的 WebDAV"></a>扩展 HTTP/1.1 的 WebDAV</h3><p>针对服务器上的资源，WebDAV 新增加了一些概念，如下所示。</p>
<ul>
<li>集合（Collection）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。</li>
<li>资源（Resource）：把文件或集合称为资源。</li>
<li>属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。</li>
<li>锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。</li>
</ul>
<h3 id="WebDAV-内新增的方法及状态码"><a href="#WebDAV-内新增的方法及状态码" class="headerlink" title="WebDAV 内新增的方法及状态码"></a>WebDAV 内新增的方法及状态码</h3><p>WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。</p>
<ul>
<li>PROPFIND ：获取属性</li>
<li>PROPPATCH ：修改属性</li>
<li>MKCOL ：创建集合</li>
<li>COPY ：复制资源及属性</li>
<li>MOVE ：移动资源</li>
<li>LOCK ：资源加锁</li>
<li>UNLOCK ：资源解锁</li>
</ul>
<p>为配合扩展的方法，状态码也随之扩展。</p>
<ul>
<li>102 Processing ：可正常处理请求，但目前是处理中状态</li>
<li>207 Multi-Status ：存在多种状态</li>
<li>422 Unprocessible Entity ：格式正确，内容有误</li>
<li>423 Locked ：资源已被加锁</li>
<li>424 Failed Dependency ：处理与某请求关联的请求失败，因此不再维持依赖关系</li>
<li>507 Insufficient Storage ：保存空间不足</li>
</ul>
<h3 id="WebDAV-的请求实例"><a href="#WebDAV-的请求实例" class="headerlink" title="WebDAV 的请求实例"></a>WebDAV 的请求实例</h3><p>下面是使用 PROPFIND 方法对 <a href="http://www.example.com/file" target="_blank" rel="noopener">http://www.example.com/file</a> 发起获取属性的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PROPFIND /file HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/xml; charset=&quot;utf-8&quot;</span><br><span class="line">Content-Length: 219</span><br><span class="line">　</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;D:propfind xmlns:D=&quot;DAV:&quot;&gt;</span><br><span class="line">  &lt;D:prop xmlns:R=&quot;http://ns.example.com/boxschema/&quot;&gt;</span><br><span class="line">  &lt;R:bigbox/&gt;</span><br><span class="line">    &lt;R:author/&gt;</span><br><span class="line">    &lt;R:DingALing/&gt;</span><br><span class="line">    &lt;R:Random/&gt;</span><br><span class="line">  &lt;/D:prop&gt;</span><br><span class="line">&lt;/D:propfind&gt;</span><br></pre></td></tr></table></figure>
<h3 id="WebDAV-的响应实例"><a href="#WebDAV-的响应实例" class="headerlink" title="WebDAV 的响应实例"></a>WebDAV 的响应实例</h3><p>下面是针对之前的 PROPFIND 方法，返回 <a href="http://www.example.com/file" target="_blank" rel="noopener">http://www.example.com/file</a> 的属性的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 207 Multi-Status</span><br><span class="line">Content-Type: application/xml; charset=&quot;utf-8&quot;</span><br><span class="line">Content-Length: 831</span><br><span class="line">　</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;D:multistatus xmlns:D=&quot;DAV:&quot;&gt;</span><br><span class="line">  &lt;D:response xmlns:R=&quot;http://ns.example.com/boxschema/&quot;&gt;</span><br><span class="line">    &lt;D:href&gt;http://www.example.com/file&lt;/D:href&gt;</span><br><span class="line">    &lt;D:propstat&gt;</span><br><span class="line">      &lt;D:prop&gt;</span><br><span class="line">        &lt;R:bigbox&gt;</span><br><span class="line">        &lt;R:BoxType&gt;Box type A&lt;/R:BoxType&gt;</span><br><span class="line">        &lt;/R:bigbox&gt;</span><br><span class="line">        &lt;R:author&gt;</span><br><span class="line">        &lt;R:Name&gt;J.J. Johnson&lt;/R:Name&gt;</span><br><span class="line">        &lt;/R:author&gt;</span><br><span class="line">      &lt;/D:prop&gt;</span><br><span class="line">      &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;</span><br><span class="line">    &lt;/D:propstat&gt;</span><br><span class="line">    &lt;D:propstat&gt;</span><br><span class="line">      &lt;D:prop&gt;&lt;R:DingALing/&gt;&lt;R:Random/&gt;&lt;/D:prop&gt;</span><br><span class="line">      &lt;D:status&gt;HTTP/1.1 403 Forbidden&lt;/D:status&gt;</span><br><span class="line">      &lt;D:responsedescription&gt; The user does not have access to the DingALing property.</span><br><span class="line">      &lt;/D:responsedescription&gt;</span><br><span class="line">    &lt;/D:propstat&gt;</span><br><span class="line">  &lt;/D:response&gt;</span><br><span class="line">  &lt;D:responsedescription&gt; There has been an access violation error.</span><br><span class="line">  &lt;/D:responsedescription&gt;</span><br><span class="line">&lt;/D:multistatus&gt;</span><br></pre></td></tr></table></figure>
<h2 id="QUIC-amp-HTTP3-0"><a href="#QUIC-amp-HTTP3-0" class="headerlink" title="QUIC&amp;HTTP3.0"></a>QUIC&amp;HTTP3.0</h2><p>参考文章：<a href="https://www.cnblogs.com/Leo_wl/p/10530323.html#_label7" target="_blank" rel="noopener">https://www.cnblogs.com/Leo_wl/p/10530323.html#_label7</a></p>
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/32553477" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32553477</a></p>
<p>HTTP2.0是基于SPDY协议的，类似的，HTTP3.0是基于QUIC协议的。SPDY和QUIC都是谷歌制定的，谷歌牛逼。</p>
<p><img src="https://pic2.zhimg.com/v2-0a847430b0a7696a1c2d59ecb7e715bd_r.jpg" alt=""></p>
<p>Google 在 <em>SPDY</em> 白皮书里表示要向协议栈下面渗透并替换掉<em>传输层</em>协议（TCP），<em>但是</em>因为这样无论是部署起来还是<em>实现</em>起来暂时相当困难。事实上TCP协议有很多顽疾无法解决，对此，谷歌推出了基于UDP的新协议——QUIC。</p>
<p>2018年底，互联网工程任务组正式将基于 QUIC 协议的 HTTP （HTTP over QUIC）重命名为 <strong>HTTP/3</strong>。</p>
<h3 id="HTTP2-0存在的问题"><a href="#HTTP2-0存在的问题" class="headerlink" title="HTTP2.0存在的问题"></a>HTTP2.0存在的问题</h3><h4 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h4><p>虽然HTTP2.0解决了之前HTTP1.1的很多问题，但还有存在一些问题，主要还是底层的TCP协议造成的。之前提到了HTTP2.0采取了多路复用的方法，一般来说，同一个域名下只需要一个TCP连接。但是，当这个TCP连接出现了丢包的情况，那么就会导致HTTP2.0的表现反而不如HTTP1.1了，为什么呢？因此HTTP2.0下，一旦TCP连接出现丢包的情况，整个的连接都要等待重传，也就导致了后面所有数据都被阻塞住了，而对于HTTP1.1来说，它是开启多个TCP连接的，出现丢包的情况也就影响其中的一个连接而不会殃及其他的TCP连接，剩余的TCP连接还能正常传输数据。对于这种情况，我们称之为<strong>队头阻塞</strong>。</p>
<p>另外 TLS 协议层面也有一个队头阻塞，因为 TLS 协议都是按照 record 来处理数据的，如果一个 record 中丢失了数据，也会导致整个 record 无法正确处理。</p>
<p>可见，对于HTTP2.0的优化，在某些情况下反而阻碍了性能的发展。那么就有人想要考虑修改TCP协议，但是这基本上是不可能的了，TCP出现的历史太久了，应用的范围也及其广，而且是在操作系统层面实现的，很难再推翻重做了。</p>
<h4 id="建立连接的握手延迟大"><a href="#建立连接的握手延迟大" class="headerlink" title="建立连接的握手延迟大"></a>建立连接的握手延迟大</h4><p>不管是HTTP1.0、HTTP1.1、HTTPS，还是HTTP2.0，都是使用的TCP协议进行传输，其中HTTPS和HTTP2.0还要使用TLS协议进行安全传输，这就出现了两个握手延迟。</p>
<ol>
<li>TCP 三次握手导致的 TCP 连接建立的延迟。<br>2.TLS 完全握手需要至少 2 个 RTT 才能建立，简化握手需要 1 个 RTT 的握手延迟。<br>对于很多短连接场景，这样的握手延迟影响很大，且无法消除。</li>
</ol>
<h3 id="QUIC的特性"><a href="#QUIC的特性" class="headerlink" title="QUIC的特性"></a>QUIC的特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 0RTT  连接建立延时低</span><br><span class="line">- 没有对头阻塞的多路复用</span><br><span class="line">- 加密认证的报文</span><br><span class="line">- 向前纠错机制</span><br></pre></td></tr></table></figure>
<h4 id="QUIC核心特性连接建立延时低"><a href="#QUIC核心特性连接建立延时低" class="headerlink" title="QUIC核心特性连接建立延时低"></a>QUIC核心特性连接建立延时低</h4><p>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。</p>
<ol>
<li>传输层 0RTT 就能建立连接。</li>
<li>加密层 0RTT 就能建立加密连接。</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-b4b3eb89464b192eed0304e5647a2d26_hd.jpg" alt="img">图 1 HTTPS 及 QUIC 建连过程</p>
<p>比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption[14]，也需要至少 2 个 RTT。</p>
<p>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密 [15] 的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket[13] 要高很多。</p>
<h4 id="没有队头阻塞的多路复用"><a href="#没有队头阻塞的多路复用" class="headerlink" title="没有队头阻塞的多路复用"></a>没有队头阻塞的多路复用</h4><p>虽然HTTP2.0实现了多路复用，但前面也提到过，存在队头阻塞的问题。而<strong>QUIC原生就实现了多路复用</strong>，并且传输的单个数据流，可以保证有序交付，而且不会影响到其他的数据流。这样就解决了TCP存在的一些问题。</p>
<p>同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。比如下图中stream2丢了一个UDP包，不会影响后面跟着 Stream3 和 Stream4，不存在 TCP 队头阻塞。虽然stream2的那个包需要重新传，但是stream3、stream4的包无需等待，就可以发给用户。</p>
<p><img src="https://image.fundebug.com/2019-03-06-8.png" alt="img"></p>
<p>另外QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p>
<h4 id="加密认证的报文"><a href="#加密认证的报文" class="headerlink" title="加密认证的报文"></a>加密认证的报文</h4><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p>
<p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p>
<p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p>
<p><img src="https://image.fundebug.com/2019-03-06-9.png" alt="img"></p>
<p>如上图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。</p>
<h4 id="向前纠错机制"><a href="#向前纠错机制" class="headerlink" title="向前纠错机制"></a>向前纠错机制</h4><p>QUIC协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此<strong>少量的丢包可以通过其他包的冗余数据直接组装而无需重传</strong>。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)</p>
<p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。<strong>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP/1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷</li>
<li>HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的</li>
<li>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议</li>
<li>但目前HTTP1.1仍然是主流，HTTP2.0都尚未普及，改动力度更大的HTTP3.0就更加需要我们等待了</li>
</ul>
<h2 id="Web安全攻击概述"><a href="#Web安全攻击概述" class="headerlink" title="Web安全攻击概述"></a>Web安全攻击概述</h2><p><strong>WASC</strong>（web application security consortium）是一个由安全专家、行业顾问和诸多组织的代表组成的国际团体，他们负责为www万维网制定被广为接受的应用安全标准。</p>
<p><strong>WASC将web安全威胁分为六大块</strong>：</p>
<ol>
<li>Authentication（验证）：用来确认某用户、服务或是应用身份的攻击手段</li>
<li>Authorization（授权）：用来决定是否某用户、服务或者是应用具有执行请求动作必要权限的攻击手段</li>
<li>Client-Side Attacks（客户侧攻击）：用来扰乱或者是探测web站点用户的攻击手段</li>
<li>Command Execution（命令执行）：在web站点上执行远程命令的攻击手段</li>
<li>Information Disclosure（信息泄露）：用来获取 web站点具体系统信息的攻击手段</li>
<li>Logical Attacks（逻辑性攻击）：用来扰乱或是探测web应用逻辑流程的攻击手段</li>
</ol>
<p>OWASP（Open Web Application Security Project）该组织致力于发现和解决不安全Web应用的根本原因。他们最重要的项目之一是“web应用的十大安全隐患”，总结了目前web应用最常收到的十种攻击手段，并按照攻击发生的频率进行了排序。</p>
<p>官网链接：<a href="http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf" target="_blank" rel="noopener">http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf</a></p>
<p><img src="https://pic2.zhimg.com/v2-9d75b28cfede20e3caf3d1f8df491e05_r.jpg" alt=""></p>
<h3 id="验证机制概述"><a href="#验证机制概述" class="headerlink" title="验证机制概述"></a>验证机制概述</h3><p>验证机制是web应用中最简单的一层安全机制。</p>
<p>一般来说，应用程序必须核实用户提交的用户名和密码是否正确。正确则允许登录，否则禁止登录。用户通过一个post请求，将用户名和密码提交到服务器，服务器端的代码逻辑进行验证。</p>
<p>验证机制是应用程序防御恶意攻击的<strong>核心机制</strong>，也是最外围的一层防御机制。它处在安全防御的最前沿，如果被轻易的突破，通常应用程序的全部功能、数据都会被恶意控制。所以，如果<strong>缺乏了安全有效的验证机制</strong>，其他核心安全机制都无法实施（会话管理和访问控制）。</p>
<p><strong>验证机制</strong>、<strong>会话管理</strong>和<strong>访问控制</strong>构成了三大防御机制。</p>
<p><img src="https://pic1.zhimg.com/v2-3ed5a7f3bb2743324320fa446d4b167c_r.jpg" alt=""></p>
<p>我们讲的验证机制，着重于用户登录到session生成这一阶段。</p>
<p><strong>验证技术</strong></p>
<ul>
<li><p>基于HTML表单的验证（最常用）</p>
<ul>
<li>如用户名+密码+验证码</li>
</ul>
</li>
<li><p>多元机制，如组合型密码和物理令牌</p>
<ul>
<li>如要求用户输入账号+密码之后，还要回答一个验证问题</li>
</ul>
</li>
<li><p>客户端SSL证书或智能卡（成本非常昂贵）</p>
<ul>
<li>常用于网银</li>
</ul>
</li>
</ul>
<p><strong>验证机制中的不安全因素</strong></p>
<ul>
<li><p><strong>弱密码</strong></p>
<p>许多web应用程序没有或者很少对用户的密码强度进行控制</p>
<ul>
<li>非常短或者空白的密码</li>
<li>非常简单的密码，如123456、password</li>
<li>密码与用户名完全相同</li>
<li>长时间使用默认密码</li>
</ul>
</li>
<li><p><strong>暴力破解</strong></p>
<p>登录功能的公开性会诱使攻击者试图猜测用户名和密码，从而获得访问应用程序的权力。如果应用程序允许攻击者用不同的密码暴力尝试，直到他找到正确的密码，这个程序就非常容易遭受攻击。</p>
<p>如今的带宽和服务器处理能力，每分钟可以发出几千甚至上万个登录尝试，如果没有一些安全措施的话，再强大的密码也最终会被攻破。</p>
<p>应对暴力破解，比较 有效的是采用验证码技术，从最简单的几个数字、字母、汉字、到问题回答和滑动滑块。</p>
</li>
</ul>
<p><strong>Cookie和会话检测</strong></p>
<p>有些应用程序会设置一个cookie，如failedlogin=0；登录尝试失败，递增该值，达到某个上限，则拒绝其再次登录尝试。</p>
<p>这样有用吗？也不一定有用，攻击者可以劫持发出的请求，将请求头中的cookie的值改掉。这样又无法防止暴力破解了。</p>
<p><strong>双因子认证</strong></p>
<p>参考文章：<a href="https://www.aqniu.com/vendor/45775.html" target="_blank" rel="noopener">https://www.aqniu.com/vendor/45775.html</a></p>
<ul>
<li>双因子认证的核心是综合what you know（个人密码）和what you have（手机）来达到双重认证效果。常见的形式就是输入密码后要输入手机收到的验证码（注意这里的验证码和前面所提到的看图读验证码是不一样的），这种双因子认证更加安全靠谱。</li>
</ul>
<p><strong>忘记密码模块</strong></p>
<ul>
<li>当前多数的应用程序和网站都回提供“忘记密码”功能，但是如果忘记密码的流程跳过了<strong>身份验证</strong>了完蛋了。</li>
<li>通常“忘记密码”操作的几种认证用户的方式：<ol>
<li>用户设定的安全问题（早期QQ主要使用这个）</li>
<li>用户注册时留下的安全邮箱</li>
<li>绑定的手机号接收验证码短信</li>
<li>联系客服</li>
</ol>
</li>
</ul>
<p><strong>这部分视频后部分看一下，讲的是验证机制漏洞的几个实例，我暂时不做笔记了，了解即可</strong></p>
<h3 id="会话管理机制"><a href="#会话管理机制" class="headerlink" title="会话管理机制"></a>会话管理机制</h3><p>绝大多数web应用程序中，会话管理机制是一个基本的安全组件。会话管理在应用程序执行登录功能时显得特别重要。因为，它可以在用户通过请求提交他们的证书后，持续向应用程序保证任何特定用户身份的真实性。</p>
<p>用户登录成功后，服务器端会分配一个session，即一个会话，客户端将这个会话令牌存到cookie中，那么之后所有的请求，拿着这个会话令牌，就可以告诉服务器我是合法用户，我有相应的权限。</p>
<p>由于一些开发者对会话管理的逻辑设计得不够严谨，会话管理常常成为针对应用程序的恶意攻击的主要目标。若攻击者能够破坏应用程序的会话管理，他就能轻易避开应用程序实施的验证机制，不需要用户证书就可以伪装成应用程序用户。</p>
<p>如果攻击者以这种方式攻破一个管理用户，那么他就能控制整个应用程序。</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>几乎每个web应用都需要使用数据库来保存操作所需的各种信息，而SQL注入就是主要针对数据库的攻击。</p>
<p>web程序经常会建立和执行用户操作数据的SQL语句。但是，如果建立这种语句的方法不安全，那么应用程序就很容易收到SQL注入的攻击。最严重的情况下，攻击者可以利用SQL注入读取甚至修改数据库中的所有数据。</p>
<p>用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL Injection，即SQL注入。</p>
<h3 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h3><p>跨站脚本攻击(Cross  site  scripting)，xss是一种经常在web应用中的计算机安全漏洞。它允许恶意web用户将代码植入到提供给其他用户使用的页面中，其他用户在观看网页时，恶意脚本就会执行。</p>
<p>xss攻击通常通过注入HTML或JS等脚本发动攻击。攻击成功后，攻击者可以得到私密网页内容和cookie等。比如一些钓鱼网站，做了一个假的qq登录界面，诱使用户输入用户名和密码。</p>
<p>xss攻击的危害：</p>
<ol>
<li>盗取各类用户账号密码</li>
<li>控制数据，包括读取、篡改、添加、删除企业敏感数据的能力</li>
<li>盗窃企业重要的具有商业价值的资料。</li>
<li>非法转账</li>
<li>控制受害者机器成为肉机，向其他网站发起攻击或者挖比特币。</li>
</ol>
<p>xss攻击案例：</p>
<ul>
<li>MySpace</li>
<li>apache</li>
</ul>
<p><strong>xss分类</strong></p>
<p>针对xss的攻击方式不同，我们可以把xss分为如下三大类：</p>
<ol>
<li>反射式xss</li>
<li>存储式xss</li>
<li>基于dom的xss</li>
</ol>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>CSRF（cross-site request forgery），跨站请求伪造，也称为“one click attack”（可以理解为一点就中）或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。</p>
<p>尽管听起来像跨站脚本攻击xss，但它与xss非常不同，攻击方式几乎相左。</p>
<p>xss利用站点内的信任用户（受害者），而CSRF通过伪装来自受信任用户的请求来利用受信任的网站。</p>
<p>通过社会工程学的手段（如通过电子邮件发送一个链接）来蛊惑受害者进行一些敏感性的操作，如修改密码、修改Email、转账等，而受害者还不知道他已中招。</p>
<h4 id="CSRF-攻击的危害性"><a href="#CSRF-攻击的危害性" class="headerlink" title="CSRF 攻击的危害性"></a>CSRF 攻击的危害性</h4><ul>
<li>CSRF的破坏力依赖于受害者的权限。如果受害者只是一个普通用户，则只是危害用户的数据以及一些功能；如果受害者具有管理员权限，则一个成功的CSRF攻击甚至会威胁到整个网站的安全。</li>
<li>与xss攻击相比，CSRF攻击往往不太流行，因此对其进行防范的资源也较为稀少，和难以防范。事实上，CSRF被认为比xss更具危险性。</li>
</ul>
<h4 id="CSRF攻击案例"><a href="#CSRF攻击案例" class="headerlink" title="CSRF攻击案例"></a>CSRF攻击案例</h4><p>小明登录了一个金融网站mybank.com，攻击者小李发现了这个金融网站mybank.com的转账功能有CSRF漏洞，于是攻击者小李在myblog.com上发表了一条博文，这个博文支持img图片自定义功能，攻击者小李就在这博文中插入了这么一行危险的html代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.mybank.com/Transfer.php?toBankId=xiaoli&amp;money=10000"</span> <span class="attr">width</span>=<span class="string">"1"</span> <span class="attr">height</span>=<span class="string">"1"</span> <span class="attr">border</span>=<span class="string">"0"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>并诱使小明在已登录自己的金融网站的同时访问小李的危险博客，这时候一个CSRF攻击就开始了。于是小明的账户就不知不觉地向小李的账户转账了10000而自己毫不知情。</p>
<h4 id="攻击过程深度剖析"><a href="#攻击过程深度剖析" class="headerlink" title="攻击过程深度剖析"></a>攻击过程深度剖析</h4><ol>
<li><p>web浏览器对于cookie和http身份验证信息之类的会话信息的处理方式：</p>
<ul>
<li><p>目前，浏览器会自动的发送标识用户对话的信息，而无需用户自己操作</p>
</li>
<li><p>换句话说，当浏览器发送这些身份信息的时候，用户根本感觉不到。</p>
</li>
<li><p>假设站点A上有个web应用程序，并且受害者正好已经在该站点上通过了身份认证，这时，相应消息中就会有cookie来记录这个信息。</p>
<p>一般情况下，浏览器收到站点设置的cookie信息后，每当向该站点发送请求的时候，浏览器都会自动的连同该cookie一起发出。</p>
<p>这个cookie是被站点作为用户会话的标志，即如果站点收到 了带有受害者的cookie的请求，那么它会把这个请求看作是已登录的受害者发来的。</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>应用程序赖以管理会话的信息对浏览器的透明性问题：</p>
<p>为了提高web应用的便捷性，<strong>用来管理会话的信息</strong>，如cookie或者基于HTTP的身份验证（如HTTP基本认证、非基于表单的认证）等<strong>敏感信息，都是由浏览器来存放的</strong>。并在每当向需要身份验证的应用程序发送请求时自动捎带上。这就为跨站请求伪造CSRF创造了条件。因为web应用程序不会判断这个请求到底是不是合法用户发送的，它只要看到了有正确的会话管理信息就认可。</p>
</li>
</ol>
<h3 id="CSRF攻击的防御"><a href="#CSRF攻击的防御" class="headerlink" title="CSRF攻击的防御"></a>CSRF攻击的防御</h3><ol>
<li><p>增加一些确认操作</p>
<p>比如说上面的转账功能，当用户调用api进行转账的时候，弹出一个对话框，例如：你确定转账10000元吗？</p>
<p>这样CSRF受害者就可以知道他可能中招了。</p>
</li>
<li><p>重新认证</p>
<p>在做一些重要敏感操作的时候，要求用户重新输入密码进行二次验证，只有正确了才进行操作。点典型的一般金融转账类的应用程序会要求用户除了有账号密码还要有支付密码。</p>
</li>
<li><p>使用token（最佳）</p>
<p>在用户刚登录的时候，产生一个新的不可预知的CSRF Token，并且把此Token存放在用户的session中。</p>
<p>在任何一个需要保护的表单中，增加一个隐藏的字段来存放这个token。</p>
<p>对于需要保护的URL，增加一个参数来存放此token。</p>
<p>提交此请求的时候， 在服务端检查提交的token与用户session中的token是否一支，继续处理请求，否则返回一个错误信息给用户。</p>
<p>在用户推出或者session过期的时候，用户信息（包括CSRF Token）从session中溢出并且销毁session。</p>
</li>
</ol>
<h2 id="未完待续⚠"><a href="#未完待续⚠" class="headerlink" title="未完待续⚠"></a>未完待续⚠</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/计算机网络/" rel="tag"># 计算机网络</a>
          
            <a href="/tags/HTTP/" rel="tag"># HTTP</a>
          
            <a href="/tags/web安全/" rel="tag"># web安全</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/23/小程序云函数路由优化之tcb-router.html" rel="next" title="小程序云函数路由优化之tcb-router">
                <i class="fa fa-chevron-left"></i> 小程序云函数路由优化之tcb-router
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/02/objectPrototypetoStringcall.html" rel="prev" title="判断一个数据的具体类型的方法">
                判断一个数据的具体类型的方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  
  </article>
  




    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Dunteng Lin">
            
              <p class="site-author-name" itemprop="name">Dunteng Lin</p>
              <p class="site-description motion-element" itemprop="description">都会好的  总会有的</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dunteng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2568678437@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/dunteng_lin" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器背后"><span class="nav-number">1.</span> <span class="nav-text">浏览器背后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器的一个请求从发起到返回经历了什么"><span class="nav-number">1.1.</span> <span class="nav-text">浏览器的一个请求从发起到返回经历了什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初识HTTP协议"><span class="nav-number">2.</span> <span class="nav-text">初识HTTP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP协议族与HTTP协议"><span class="nav-number">3.</span> <span class="nav-text">TCP/IP协议族与HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP分层"><span class="nav-number">3.1.</span> <span class="nav-text">TCP/IP分层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据封装与数据传输"><span class="nav-number">3.2.</span> <span class="nav-text">数据封装与数据传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP连接的建立和释放"><span class="nav-number">3.3.</span> <span class="nav-text">TCP连接的建立和释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS域名解析和CDN"><span class="nav-number">4.</span> <span class="nav-text">DNS域名解析和CDN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发者工具查看http请求头响应头响应体"><span class="nav-number">5.</span> <span class="nav-text">开发者工具查看http请求头响应头响应体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP协议五大特点"><span class="nav-number">6.</span> <span class="nav-text">HTTP协议五大特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#URI和URL的区别与联系"><span class="nav-number">7.</span> <span class="nav-text">URI和URL的区别与联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP报文结构分析"><span class="nav-number">8.</span> <span class="nav-text">HTTP报文结构分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求报文"><span class="nav-number">8.1.</span> <span class="nav-text">请求报文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP报文头"><span class="nav-number">8.2.</span> <span class="nav-text">HTTP报文头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的报文头字段"><span class="nav-number">8.3.</span> <span class="nav-text">常见的报文头字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应报文"><span class="nav-number">8.4.</span> <span class="nav-text">响应报文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP请求方法"><span class="nav-number">9.</span> <span class="nav-text">HTTP请求方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GET"><span class="nav-number">9.1.</span> <span class="nav-text">GET</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POST"><span class="nav-number">9.2.</span> <span class="nav-text">POST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PUT"><span class="nav-number">9.3.</span> <span class="nav-text">PUT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HEAD"><span class="nav-number">9.4.</span> <span class="nav-text">HEAD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DELETE"><span class="nav-number">9.5.</span> <span class="nav-text">DELETE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OPTIONS"><span class="nav-number">9.6.</span> <span class="nav-text">OPTIONS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TARCE"><span class="nav-number">9.7.</span> <span class="nav-text">TARCE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONNECT"><span class="nav-number">9.8.</span> <span class="nav-text">CONNECT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态码"><span class="nav-number">10.</span> <span class="nav-text">状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的状态码"><span class="nav-number">10.1.</span> <span class="nav-text">常见的状态码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP状态管理（会话机制）：Cookie和Session"><span class="nav-number">11.</span> <span class="nav-text">HTTP状态管理（会话机制）：Cookie和Session</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie"><span class="nav-number">11.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session"><span class="nav-number">11.2.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie与session配合使用"><span class="nav-number">11.3.</span> <span class="nav-text">cookie与session配合使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器禁用cookie"><span class="nav-number">11.4.</span> <span class="nav-text">浏览器禁用cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie与session的不同"><span class="nav-number">11.5.</span> <span class="nav-text">cookie与session的不同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP协议中的编码和解码"><span class="nav-number">12.</span> <span class="nav-text">HTTP协议中的编码和解码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符集与编码"><span class="nav-number">12.1.</span> <span class="nav-text">字符集与编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的编码规范"><span class="nav-number">12.2.</span> <span class="nav-text">常见的编码规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乱码的由来"><span class="nav-number">12.3.</span> <span class="nav-text">乱码的由来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL的编码与解码"><span class="nav-number">12.4.</span> <span class="nav-text">URL的编码与解码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP协议之身份认证"><span class="nav-number">13.</span> <span class="nav-text">HTTP协议之身份认证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BASIC基本认证"><span class="nav-number">13.1.</span> <span class="nav-text">BASIC基本认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DIGEST认证"><span class="nav-number">13.2.</span> <span class="nav-text">DIGEST认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL客户端认证"><span class="nav-number">13.3.</span> <span class="nav-text">SSL客户端认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于表单的认证"><span class="nav-number">13.4.</span> <span class="nav-text">基于表单的认证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#长连接与短连接"><span class="nav-number">14.</span> <span class="nav-text">长连接与短连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP中介之代理proxy"><span class="nav-number">15.</span> <span class="nav-text">HTTP中介之代理proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代理服务器的作用"><span class="nav-number">15.1.</span> <span class="nav-text">代理服务器的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用代理服务器的安全问题"><span class="nav-number">15.2.</span> <span class="nav-text">使用代理服务器的安全问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP中介之网关gateway"><span class="nav-number">16.</span> <span class="nav-text">HTTP中介之网关gateway</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的几种网关"><span class="nav-number">16.1.</span> <span class="nav-text">常见的几种网关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP缓存"><span class="nav-number">17.</span> <span class="nav-text">HTTP缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP缓存头部字段"><span class="nav-number">17.1.</span> <span class="nav-text">HTTP缓存头部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP缓存工作方式"><span class="nav-number">17.2.</span> <span class="nav-text">HTTP缓存工作方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Expires"><span class="nav-number">17.2.1.</span> <span class="nav-text">Expires</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Last-Modified与if-Modified-Since"><span class="nav-number">17.2.2.</span> <span class="nav-text">Last-Modified与if-Modified-Since</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Etag与If-None-Match"><span class="nav-number">17.2.3.</span> <span class="nav-text">Etag与If-None-Match</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存改进方案"><span class="nav-number">17.3.</span> <span class="nav-text">缓存改进方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-md5-hash缓存"><span class="nav-number">17.3.1.</span> <span class="nav-text">1.md5/hash缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-CDN缓存"><span class="nav-number">17.3.2.</span> <span class="nav-text">2.CDN缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器操作对HTTP缓存的影响"><span class="nav-number">17.4.</span> <span class="nav-text">浏览器操作对HTTP缓存的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强缓存与协商性缓存-弱缓存"><span class="nav-number">17.5.</span> <span class="nav-text">强缓存与协商性缓存(弱缓存)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内容协商机制"><span class="nav-number">18.</span> <span class="nav-text">内容协商机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充一下：请求体-响应体和实体的区别"><span class="nav-number">19.</span> <span class="nav-text">补充一下：请求体/响应体和实体的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#断点续传和多线程分块下载"><span class="nav-number">20.</span> <span class="nav-text">断点续传和多线程分块下载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初识HTTP与HTTPS"><span class="nav-number">21.</span> <span class="nav-text">初识HTTP与HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对称加密"><span class="nav-number">21.1.</span> <span class="nav-text">对称加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非对称加密"><span class="nav-number">21.2.</span> <span class="nav-text">非对称加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入证书"><span class="nav-number">21.3.</span> <span class="nav-text">引入证书</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS协议概述"><span class="nav-number">22.</span> <span class="nav-text">HTTPS协议概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS的功能"><span class="nav-number">22.1.</span> <span class="nav-text">HTTPS的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS使用成本"><span class="nav-number">22.2.</span> <span class="nav-text">HTTPS使用成本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS对性能的影响"><span class="nav-number">22.3.</span> <span class="nav-text">HTTPS对性能的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS常见问答"><span class="nav-number">22.4.</span> <span class="nav-text">HTTPS常见问答</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP的瓶颈"><span class="nav-number">23.</span> <span class="nav-text">HTTP的瓶颈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP的缺陷"><span class="nav-number">24.</span> <span class="nav-text">HTTP的缺陷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket"><span class="nav-number">25.</span> <span class="nav-text">WebSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单工、半双工和全双工"><span class="nav-number">25.1.</span> <span class="nav-text">单工、半双工和全双工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#websocket建立握手"><span class="nav-number">25.2.</span> <span class="nav-text">websocket建立握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ajax轮询和long-poll长轮询"><span class="nav-number">25.3.</span> <span class="nav-text">Ajax轮询和long poll长轮询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket解决方案"><span class="nav-number">25.4.</span> <span class="nav-text">webSocket解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPDY协议"><span class="nav-number">26.</span> <span class="nav-text">SPDY协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP2-0"><span class="nav-number">27.</span> <span class="nav-text">HTTP2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">27.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-number">27.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制传输"><span class="nav-number">27.3.</span> <span class="nav-text">二进制传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制分帧层"><span class="nav-number">27.3.1.</span> <span class="nav-text">二进制分帧层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#首部压缩"><span class="nav-number">27.4.</span> <span class="nav-text">首部压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多路复用"><span class="nav-number">27.5.</span> <span class="nav-text">多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#所有的-HTTP2-0-的请求都在一个-TCP-链接上"><span class="nav-number">27.5.1.</span> <span class="nav-text">所有的 HTTP2.0 的请求都在一个 TCP 链接上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行双向字节流的请求和响应"><span class="nav-number">27.5.2.</span> <span class="nav-text">并行双向字节流的请求和响应</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求优先级"><span class="nav-number">27.6.</span> <span class="nav-text">请求优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器推送"><span class="nav-number">27.7.</span> <span class="nav-text">服务器推送</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebDAV（了解）"><span class="nav-number">28.</span> <span class="nav-text">WebDAV（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展-HTTP-1-1-的-WebDAV"><span class="nav-number">28.1.</span> <span class="nav-text">扩展 HTTP/1.1 的 WebDAV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebDAV-内新增的方法及状态码"><span class="nav-number">28.2.</span> <span class="nav-text">WebDAV 内新增的方法及状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebDAV-的请求实例"><span class="nav-number">28.3.</span> <span class="nav-text">WebDAV 的请求实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebDAV-的响应实例"><span class="nav-number">28.4.</span> <span class="nav-text">WebDAV 的响应实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QUIC-amp-HTTP3-0"><span class="nav-number">29.</span> <span class="nav-text">QUIC&amp;HTTP3.0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP2-0存在的问题"><span class="nav-number">29.1.</span> <span class="nav-text">HTTP2.0存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#队头阻塞"><span class="nav-number">29.1.1.</span> <span class="nav-text">队头阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建立连接的握手延迟大"><span class="nav-number">29.1.2.</span> <span class="nav-text">建立连接的握手延迟大</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QUIC的特性"><span class="nav-number">29.2.</span> <span class="nav-text">QUIC的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#QUIC核心特性连接建立延时低"><span class="nav-number">29.2.1.</span> <span class="nav-text">QUIC核心特性连接建立延时低</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#没有队头阻塞的多路复用"><span class="nav-number">29.2.2.</span> <span class="nav-text">没有队头阻塞的多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加密认证的报文"><span class="nav-number">29.2.3.</span> <span class="nav-text">加密认证的报文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向前纠错机制"><span class="nav-number">29.2.4.</span> <span class="nav-text">向前纠错机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">29.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web安全攻击概述"><span class="nav-number">30.</span> <span class="nav-text">Web安全攻击概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#验证机制概述"><span class="nav-number">30.1.</span> <span class="nav-text">验证机制概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会话管理机制"><span class="nav-number">30.2.</span> <span class="nav-text">会话管理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL注入"><span class="nav-number">30.3.</span> <span class="nav-text">SQL注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xss攻击"><span class="nav-number">30.4.</span> <span class="nav-text">xss攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSRF攻击"><span class="nav-number">30.5.</span> <span class="nav-text">CSRF攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介"><span class="nav-number">30.5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF-攻击的危害性"><span class="nav-number">30.5.2.</span> <span class="nav-text">CSRF 攻击的危害性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF攻击案例"><span class="nav-number">30.5.3.</span> <span class="nav-text">CSRF攻击案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#攻击过程深度剖析"><span class="nav-number">30.5.4.</span> <span class="nav-text">攻击过程深度剖析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSRF攻击的防御"><span class="nav-number">30.6.</span> <span class="nav-text">CSRF攻击的防御</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未完待续⚠"><span class="nav-number">31.</span> <span class="nav-text">未完待续⚠</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" style="font-size:10px;">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dunteng Lin</span>

  
</div>







<div id="sitetime" style="font-size:10px;"></div>
<script language="javascript">
	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数 */
		var t1 = Date.UTC(2017,08,12,15,15,47); //建站时间
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>
        






        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'J29bT1MHDnsDl0O48fRK6u7D-gzGzoHsz',
        appKey: '2ftsHD4VBWJQVASwv65waJNL',
        placeholder: '欢迎评论，请在上方留下你的昵称和邮箱以便收到我的回复通知~',
        avatar:'retro',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
